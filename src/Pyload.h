/**
 * Autogenerated by Thrift Compiler (0.8.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#ifndef Pyload_H
#define Pyload_H

#include <TProcessor.h>
#include "pyload_types.h"

class PyloadIf {
 public:
  virtual ~PyloadIf() {}
  virtual void getConfigValue(std::string& _return, const std::string& category, const std::string& option, const std::string& section) = 0;
  virtual void setConfigValue(const std::string& category, const std::string& option, const std::string& value, const std::string& section) = 0;
  virtual void getConfig(std::map<std::string, ConfigSection> & _return) = 0;
  virtual void getPluginConfig(std::map<std::string, ConfigSection> & _return) = 0;
  virtual void pauseServer() = 0;
  virtual void unpauseServer() = 0;
  virtual bool togglePause() = 0;
  virtual void statusServer(ServerStatus& _return) = 0;
  virtual int64_t freeSpace() = 0;
  virtual void getServerVersion(std::string& _return) = 0;
  virtual void kill() = 0;
  virtual void restart() = 0;
  virtual void getLog(std::vector<std::string> & _return, const int32_t offset) = 0;
  virtual bool isTimeDownload() = 0;
  virtual bool isTimeReconnect() = 0;
  virtual bool toggleReconnect() = 0;
  virtual void generatePackages(std::map<std::string, LinkList> & _return, const LinkList& links) = 0;
  virtual void checkURLs(std::map<PluginName, LinkList> & _return, const LinkList& urls) = 0;
  virtual void parseURLs(std::map<PluginName, LinkList> & _return, const std::string& html) = 0;
  virtual void checkOnlineStatus(OnlineCheck& _return, const LinkList& urls) = 0;
  virtual void checkOnlineStatusContainer(OnlineCheck& _return, const LinkList& urls, const std::string& filename, const std::string& data) = 0;
  virtual void pollResults(OnlineCheck& _return, const ResultID rid) = 0;
  virtual void statusDownloads(std::vector<DownloadInfo> & _return) = 0;
  virtual void getPackageData(PackageData& _return, const PackageID pid) = 0;
  virtual void getPackageInfo(PackageData& _return, const PackageID pid) = 0;
  virtual void getFileData(FileData& _return, const FileID fid) = 0;
  virtual void getQueue(std::vector<PackageData> & _return) = 0;
  virtual void getCollector(std::vector<PackageData> & _return) = 0;
  virtual void getQueueData(std::vector<PackageData> & _return) = 0;
  virtual void getCollectorData(std::vector<PackageData> & _return) = 0;
  virtual void getPackageOrder(std::map<int16_t, PackageID> & _return, const Destination::type destination) = 0;
  virtual void getFileOrder(std::map<int16_t, FileID> & _return, const PackageID pid) = 0;
  virtual void generateAndAddPackages(std::vector<PackageID> & _return, const LinkList& links, const Destination::type dest) = 0;
  virtual PackageID addPackage(const std::string& name, const LinkList& links, const Destination::type dest) = 0;
  virtual void addFiles(const PackageID pid, const LinkList& links) = 0;
  virtual void uploadContainer(const std::string& filename, const std::string& data) = 0;
  virtual void deleteFiles(const std::vector<FileID> & fids) = 0;
  virtual void deletePackages(const std::vector<PackageID> & pids) = 0;
  virtual void pushToQueue(const PackageID pid) = 0;
  virtual void pullFromQueue(const PackageID pid) = 0;
  virtual void restartPackage(const PackageID pid) = 0;
  virtual void restartFile(const FileID fid) = 0;
  virtual void recheckPackage(const PackageID pid) = 0;
  virtual void stopAllDownloads() = 0;
  virtual void stopDownloads(const std::vector<FileID> & fids) = 0;
  virtual void setPackageName(const PackageID pid, const std::string& name) = 0;
  virtual void movePackage(const Destination::type destination, const PackageID pid) = 0;
  virtual void moveFiles(const std::vector<FileID> & fids, const PackageID pid) = 0;
  virtual void orderPackage(const PackageID pid, const int16_t position) = 0;
  virtual void orderFile(const FileID fid, const int16_t position) = 0;
  virtual void setPackageData(const PackageID pid, const std::map<std::string, std::string> & data) = 0;
  virtual void deleteFinished() = 0;
  virtual void restartFailed() = 0;
  virtual bool isCaptchaWaiting() = 0;
  virtual void getCaptchaTask(CaptchaTask& _return, const bool exclusive) = 0;
  virtual void getCaptchaTaskStatus(std::string& _return, const TaskID tid) = 0;
  virtual void setCaptchaResult(const TaskID tid, const std::string& result) = 0;
  virtual void getEvents(std::vector<Event> & _return, const std::string& uuid) = 0;
  virtual void getAccounts(std::vector<AccountInfo> & _return, const bool refresh) = 0;
  virtual void getAccountTypes(std::vector<std::string> & _return) = 0;
  virtual void updateAccount(const PluginName& plugin, const std::string& account, const std::string& password, const std::map<std::string, std::string> & options) = 0;
  virtual void removeAccount(const PluginName& plugin, const std::string& account) = 0;
  virtual bool login(const std::string& username, const std::string& password) = 0;
  virtual void getUserData(UserData& _return, const std::string& username, const std::string& password) = 0;
  virtual void getServices(std::map<PluginName, std::map<std::string, std::string> > & _return) = 0;
  virtual bool hasService(const PluginName& plugin, const std::string& func) = 0;
  virtual void call(std::string& _return, const ServiceCall& info) = 0;
  virtual void getAllInfo(std::map<PluginName, std::map<std::string, std::string> > & _return) = 0;
  virtual void getInfoByPlugin(std::map<std::string, std::string> & _return, const PluginName& plugin) = 0;
};

class PyloadIfFactory {
 public:
  typedef PyloadIf Handler;

  virtual ~PyloadIfFactory() {}

  virtual PyloadIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(PyloadIf* /* handler */) = 0;
};

class PyloadIfSingletonFactory : virtual public PyloadIfFactory {
 public:
  PyloadIfSingletonFactory(const boost::shared_ptr<PyloadIf>& iface) : iface_(iface) {}
  virtual ~PyloadIfSingletonFactory() {}

  virtual PyloadIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(PyloadIf* /* handler */) {}

 protected:
  boost::shared_ptr<PyloadIf> iface_;
};

class PyloadNull : virtual public PyloadIf {
 public:
  virtual ~PyloadNull() {}
  void getConfigValue(std::string& /* _return */, const std::string& /* category */, const std::string& /* option */, const std::string& /* section */) {
    return;
  }
  void setConfigValue(const std::string& /* category */, const std::string& /* option */, const std::string& /* value */, const std::string& /* section */) {
    return;
  }
  void getConfig(std::map<std::string, ConfigSection> & /* _return */) {
    return;
  }
  void getPluginConfig(std::map<std::string, ConfigSection> & /* _return */) {
    return;
  }
  void pauseServer() {
    return;
  }
  void unpauseServer() {
    return;
  }
  bool togglePause() {
    bool _return = false;
    return _return;
  }
  void statusServer(ServerStatus& /* _return */) {
    return;
  }
  int64_t freeSpace() {
    int64_t _return = 0;
    return _return;
  }
  void getServerVersion(std::string& /* _return */) {
    return;
  }
  void kill() {
    return;
  }
  void restart() {
    return;
  }
  void getLog(std::vector<std::string> & /* _return */, const int32_t /* offset */) {
    return;
  }
  bool isTimeDownload() {
    bool _return = false;
    return _return;
  }
  bool isTimeReconnect() {
    bool _return = false;
    return _return;
  }
  bool toggleReconnect() {
    bool _return = false;
    return _return;
  }
  void generatePackages(std::map<std::string, LinkList> & /* _return */, const LinkList& /* links */) {
    return;
  }
  void checkURLs(std::map<PluginName, LinkList> & /* _return */, const LinkList& /* urls */) {
    return;
  }
  void parseURLs(std::map<PluginName, LinkList> & /* _return */, const std::string& /* html */) {
    return;
  }
  void checkOnlineStatus(OnlineCheck& /* _return */, const LinkList& /* urls */) {
    return;
  }
  void checkOnlineStatusContainer(OnlineCheck& /* _return */, const LinkList& /* urls */, const std::string& /* filename */, const std::string& /* data */) {
    return;
  }
  void pollResults(OnlineCheck& /* _return */, const ResultID /* rid */) {
    return;
  }
  void statusDownloads(std::vector<DownloadInfo> & /* _return */) {
    return;
  }
  void getPackageData(PackageData& /* _return */, const PackageID /* pid */) {
    return;
  }
  void getPackageInfo(PackageData& /* _return */, const PackageID /* pid */) {
    return;
  }
  void getFileData(FileData& /* _return */, const FileID /* fid */) {
    return;
  }
  void getQueue(std::vector<PackageData> & /* _return */) {
    return;
  }
  void getCollector(std::vector<PackageData> & /* _return */) {
    return;
  }
  void getQueueData(std::vector<PackageData> & /* _return */) {
    return;
  }
  void getCollectorData(std::vector<PackageData> & /* _return */) {
    return;
  }
  void getPackageOrder(std::map<int16_t, PackageID> & /* _return */, const Destination::type /* destination */) {
    return;
  }
  void getFileOrder(std::map<int16_t, FileID> & /* _return */, const PackageID /* pid */) {
    return;
  }
  void generateAndAddPackages(std::vector<PackageID> & /* _return */, const LinkList& /* links */, const Destination::type /* dest */) {
    return;
  }
  PackageID addPackage(const std::string& /* name */, const LinkList& /* links */, const Destination::type /* dest */) {
    PackageID _return = 0;
    return _return;
  }
  void addFiles(const PackageID /* pid */, const LinkList& /* links */) {
    return;
  }
  void uploadContainer(const std::string& /* filename */, const std::string& /* data */) {
    return;
  }
  void deleteFiles(const std::vector<FileID> & /* fids */) {
    return;
  }
  void deletePackages(const std::vector<PackageID> & /* pids */) {
    return;
  }
  void pushToQueue(const PackageID /* pid */) {
    return;
  }
  void pullFromQueue(const PackageID /* pid */) {
    return;
  }
  void restartPackage(const PackageID /* pid */) {
    return;
  }
  void restartFile(const FileID /* fid */) {
    return;
  }
  void recheckPackage(const PackageID /* pid */) {
    return;
  }
  void stopAllDownloads() {
    return;
  }
  void stopDownloads(const std::vector<FileID> & /* fids */) {
    return;
  }
  void setPackageName(const PackageID /* pid */, const std::string& /* name */) {
    return;
  }
  void movePackage(const Destination::type /* destination */, const PackageID /* pid */) {
    return;
  }
  void moveFiles(const std::vector<FileID> & /* fids */, const PackageID /* pid */) {
    return;
  }
  void orderPackage(const PackageID /* pid */, const int16_t /* position */) {
    return;
  }
  void orderFile(const FileID /* fid */, const int16_t /* position */) {
    return;
  }
  void setPackageData(const PackageID /* pid */, const std::map<std::string, std::string> & /* data */) {
    return;
  }
  void deleteFinished() {
    return;
  }
  void restartFailed() {
    return;
  }
  bool isCaptchaWaiting() {
    bool _return = false;
    return _return;
  }
  void getCaptchaTask(CaptchaTask& /* _return */, const bool /* exclusive */) {
    return;
  }
  void getCaptchaTaskStatus(std::string& /* _return */, const TaskID /* tid */) {
    return;
  }
  void setCaptchaResult(const TaskID /* tid */, const std::string& /* result */) {
    return;
  }
  void getEvents(std::vector<Event> & /* _return */, const std::string& /* uuid */) {
    return;
  }
  void getAccounts(std::vector<AccountInfo> & /* _return */, const bool /* refresh */) {
    return;
  }
  void getAccountTypes(std::vector<std::string> & /* _return */) {
    return;
  }
  void updateAccount(const PluginName& /* plugin */, const std::string& /* account */, const std::string& /* password */, const std::map<std::string, std::string> & /* options */) {
    return;
  }
  void removeAccount(const PluginName& /* plugin */, const std::string& /* account */) {
    return;
  }
  bool login(const std::string& /* username */, const std::string& /* password */) {
    bool _return = false;
    return _return;
  }
  void getUserData(UserData& /* _return */, const std::string& /* username */, const std::string& /* password */) {
    return;
  }
  void getServices(std::map<PluginName, std::map<std::string, std::string> > & /* _return */) {
    return;
  }
  bool hasService(const PluginName& /* plugin */, const std::string& /* func */) {
    bool _return = false;
    return _return;
  }
  void call(std::string& /* _return */, const ServiceCall& /* info */) {
    return;
  }
  void getAllInfo(std::map<PluginName, std::map<std::string, std::string> > & /* _return */) {
    return;
  }
  void getInfoByPlugin(std::map<std::string, std::string> & /* _return */, const PluginName& /* plugin */) {
    return;
  }
};

typedef struct _Pyload_getConfigValue_args__isset {
  _Pyload_getConfigValue_args__isset() : category(false), option(false), section(false) {}
  bool category;
  bool option;
  bool section;
} _Pyload_getConfigValue_args__isset;

class Pyload_getConfigValue_args {
 public:

  Pyload_getConfigValue_args() : category(""), option(""), section("") {
  }

  virtual ~Pyload_getConfigValue_args() throw() {}

  std::string category;
  std::string option;
  std::string section;

  _Pyload_getConfigValue_args__isset __isset;

  void __set_category(const std::string& val) {
    category = val;
  }

  void __set_option(const std::string& val) {
    option = val;
  }

  void __set_section(const std::string& val) {
    section = val;
  }

  bool operator == (const Pyload_getConfigValue_args & rhs) const
  {
    if (!(category == rhs.category))
      return false;
    if (!(option == rhs.option))
      return false;
    if (!(section == rhs.section))
      return false;
    return true;
  }
  bool operator != (const Pyload_getConfigValue_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getConfigValue_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getConfigValue_pargs {
 public:


  virtual ~Pyload_getConfigValue_pargs() throw() {}

  const std::string* category;
  const std::string* option;
  const std::string* section;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getConfigValue_result__isset {
  _Pyload_getConfigValue_result__isset() : success(false) {}
  bool success;
} _Pyload_getConfigValue_result__isset;

class Pyload_getConfigValue_result {
 public:

  Pyload_getConfigValue_result() : success("") {
  }

  virtual ~Pyload_getConfigValue_result() throw() {}

  std::string success;

  _Pyload_getConfigValue_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const Pyload_getConfigValue_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getConfigValue_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getConfigValue_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getConfigValue_presult__isset {
  _Pyload_getConfigValue_presult__isset() : success(false) {}
  bool success;
} _Pyload_getConfigValue_presult__isset;

class Pyload_getConfigValue_presult {
 public:


  virtual ~Pyload_getConfigValue_presult() throw() {}

  std::string* success;

  _Pyload_getConfigValue_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_setConfigValue_args__isset {
  _Pyload_setConfigValue_args__isset() : category(false), option(false), value(false), section(false) {}
  bool category;
  bool option;
  bool value;
  bool section;
} _Pyload_setConfigValue_args__isset;

class Pyload_setConfigValue_args {
 public:

  Pyload_setConfigValue_args() : category(""), option(""), value(""), section("") {
  }

  virtual ~Pyload_setConfigValue_args() throw() {}

  std::string category;
  std::string option;
  std::string value;
  std::string section;

  _Pyload_setConfigValue_args__isset __isset;

  void __set_category(const std::string& val) {
    category = val;
  }

  void __set_option(const std::string& val) {
    option = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  void __set_section(const std::string& val) {
    section = val;
  }

  bool operator == (const Pyload_setConfigValue_args & rhs) const
  {
    if (!(category == rhs.category))
      return false;
    if (!(option == rhs.option))
      return false;
    if (!(value == rhs.value))
      return false;
    if (!(section == rhs.section))
      return false;
    return true;
  }
  bool operator != (const Pyload_setConfigValue_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_setConfigValue_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_setConfigValue_pargs {
 public:


  virtual ~Pyload_setConfigValue_pargs() throw() {}

  const std::string* category;
  const std::string* option;
  const std::string* value;
  const std::string* section;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_setConfigValue_result {
 public:

  Pyload_setConfigValue_result() {
  }

  virtual ~Pyload_setConfigValue_result() throw() {}


  bool operator == (const Pyload_setConfigValue_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_setConfigValue_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_setConfigValue_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_setConfigValue_presult {
 public:


  virtual ~Pyload_setConfigValue_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_getConfig_args {
 public:

  Pyload_getConfig_args() {
  }

  virtual ~Pyload_getConfig_args() throw() {}


  bool operator == (const Pyload_getConfig_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_getConfig_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getConfig_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getConfig_pargs {
 public:


  virtual ~Pyload_getConfig_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getConfig_result__isset {
  _Pyload_getConfig_result__isset() : success(false) {}
  bool success;
} _Pyload_getConfig_result__isset;

class Pyload_getConfig_result {
 public:

  Pyload_getConfig_result() {
  }

  virtual ~Pyload_getConfig_result() throw() {}

  std::map<std::string, ConfigSection>  success;

  _Pyload_getConfig_result__isset __isset;

  void __set_success(const std::map<std::string, ConfigSection> & val) {
    success = val;
  }

  bool operator == (const Pyload_getConfig_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getConfig_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getConfig_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getConfig_presult__isset {
  _Pyload_getConfig_presult__isset() : success(false) {}
  bool success;
} _Pyload_getConfig_presult__isset;

class Pyload_getConfig_presult {
 public:


  virtual ~Pyload_getConfig_presult() throw() {}

  std::map<std::string, ConfigSection> * success;

  _Pyload_getConfig_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_getPluginConfig_args {
 public:

  Pyload_getPluginConfig_args() {
  }

  virtual ~Pyload_getPluginConfig_args() throw() {}


  bool operator == (const Pyload_getPluginConfig_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_getPluginConfig_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getPluginConfig_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getPluginConfig_pargs {
 public:


  virtual ~Pyload_getPluginConfig_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getPluginConfig_result__isset {
  _Pyload_getPluginConfig_result__isset() : success(false) {}
  bool success;
} _Pyload_getPluginConfig_result__isset;

class Pyload_getPluginConfig_result {
 public:

  Pyload_getPluginConfig_result() {
  }

  virtual ~Pyload_getPluginConfig_result() throw() {}

  std::map<std::string, ConfigSection>  success;

  _Pyload_getPluginConfig_result__isset __isset;

  void __set_success(const std::map<std::string, ConfigSection> & val) {
    success = val;
  }

  bool operator == (const Pyload_getPluginConfig_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getPluginConfig_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getPluginConfig_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getPluginConfig_presult__isset {
  _Pyload_getPluginConfig_presult__isset() : success(false) {}
  bool success;
} _Pyload_getPluginConfig_presult__isset;

class Pyload_getPluginConfig_presult {
 public:


  virtual ~Pyload_getPluginConfig_presult() throw() {}

  std::map<std::string, ConfigSection> * success;

  _Pyload_getPluginConfig_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_pauseServer_args {
 public:

  Pyload_pauseServer_args() {
  }

  virtual ~Pyload_pauseServer_args() throw() {}


  bool operator == (const Pyload_pauseServer_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_pauseServer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_pauseServer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_pauseServer_pargs {
 public:


  virtual ~Pyload_pauseServer_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_pauseServer_result {
 public:

  Pyload_pauseServer_result() {
  }

  virtual ~Pyload_pauseServer_result() throw() {}


  bool operator == (const Pyload_pauseServer_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_pauseServer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_pauseServer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_pauseServer_presult {
 public:


  virtual ~Pyload_pauseServer_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_unpauseServer_args {
 public:

  Pyload_unpauseServer_args() {
  }

  virtual ~Pyload_unpauseServer_args() throw() {}


  bool operator == (const Pyload_unpauseServer_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_unpauseServer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_unpauseServer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_unpauseServer_pargs {
 public:


  virtual ~Pyload_unpauseServer_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_unpauseServer_result {
 public:

  Pyload_unpauseServer_result() {
  }

  virtual ~Pyload_unpauseServer_result() throw() {}


  bool operator == (const Pyload_unpauseServer_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_unpauseServer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_unpauseServer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_unpauseServer_presult {
 public:


  virtual ~Pyload_unpauseServer_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_togglePause_args {
 public:

  Pyload_togglePause_args() {
  }

  virtual ~Pyload_togglePause_args() throw() {}


  bool operator == (const Pyload_togglePause_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_togglePause_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_togglePause_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_togglePause_pargs {
 public:


  virtual ~Pyload_togglePause_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_togglePause_result__isset {
  _Pyload_togglePause_result__isset() : success(false) {}
  bool success;
} _Pyload_togglePause_result__isset;

class Pyload_togglePause_result {
 public:

  Pyload_togglePause_result() : success(0) {
  }

  virtual ~Pyload_togglePause_result() throw() {}

  bool success;

  _Pyload_togglePause_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  bool operator == (const Pyload_togglePause_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_togglePause_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_togglePause_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_togglePause_presult__isset {
  _Pyload_togglePause_presult__isset() : success(false) {}
  bool success;
} _Pyload_togglePause_presult__isset;

class Pyload_togglePause_presult {
 public:


  virtual ~Pyload_togglePause_presult() throw() {}

  bool* success;

  _Pyload_togglePause_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_statusServer_args {
 public:

  Pyload_statusServer_args() {
  }

  virtual ~Pyload_statusServer_args() throw() {}


  bool operator == (const Pyload_statusServer_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_statusServer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_statusServer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_statusServer_pargs {
 public:


  virtual ~Pyload_statusServer_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_statusServer_result__isset {
  _Pyload_statusServer_result__isset() : success(false) {}
  bool success;
} _Pyload_statusServer_result__isset;

class Pyload_statusServer_result {
 public:

  Pyload_statusServer_result() {
  }

  virtual ~Pyload_statusServer_result() throw() {}

  ServerStatus success;

  _Pyload_statusServer_result__isset __isset;

  void __set_success(const ServerStatus& val) {
    success = val;
  }

  bool operator == (const Pyload_statusServer_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_statusServer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_statusServer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_statusServer_presult__isset {
  _Pyload_statusServer_presult__isset() : success(false) {}
  bool success;
} _Pyload_statusServer_presult__isset;

class Pyload_statusServer_presult {
 public:


  virtual ~Pyload_statusServer_presult() throw() {}

  ServerStatus* success;

  _Pyload_statusServer_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_freeSpace_args {
 public:

  Pyload_freeSpace_args() {
  }

  virtual ~Pyload_freeSpace_args() throw() {}


  bool operator == (const Pyload_freeSpace_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_freeSpace_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_freeSpace_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_freeSpace_pargs {
 public:


  virtual ~Pyload_freeSpace_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_freeSpace_result__isset {
  _Pyload_freeSpace_result__isset() : success(false) {}
  bool success;
} _Pyload_freeSpace_result__isset;

class Pyload_freeSpace_result {
 public:

  Pyload_freeSpace_result() : success(0) {
  }

  virtual ~Pyload_freeSpace_result() throw() {}

  int64_t success;

  _Pyload_freeSpace_result__isset __isset;

  void __set_success(const int64_t val) {
    success = val;
  }

  bool operator == (const Pyload_freeSpace_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_freeSpace_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_freeSpace_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_freeSpace_presult__isset {
  _Pyload_freeSpace_presult__isset() : success(false) {}
  bool success;
} _Pyload_freeSpace_presult__isset;

class Pyload_freeSpace_presult {
 public:


  virtual ~Pyload_freeSpace_presult() throw() {}

  int64_t* success;

  _Pyload_freeSpace_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_getServerVersion_args {
 public:

  Pyload_getServerVersion_args() {
  }

  virtual ~Pyload_getServerVersion_args() throw() {}


  bool operator == (const Pyload_getServerVersion_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_getServerVersion_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getServerVersion_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getServerVersion_pargs {
 public:


  virtual ~Pyload_getServerVersion_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getServerVersion_result__isset {
  _Pyload_getServerVersion_result__isset() : success(false) {}
  bool success;
} _Pyload_getServerVersion_result__isset;

class Pyload_getServerVersion_result {
 public:

  Pyload_getServerVersion_result() : success("") {
  }

  virtual ~Pyload_getServerVersion_result() throw() {}

  std::string success;

  _Pyload_getServerVersion_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const Pyload_getServerVersion_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getServerVersion_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getServerVersion_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getServerVersion_presult__isset {
  _Pyload_getServerVersion_presult__isset() : success(false) {}
  bool success;
} _Pyload_getServerVersion_presult__isset;

class Pyload_getServerVersion_presult {
 public:


  virtual ~Pyload_getServerVersion_presult() throw() {}

  std::string* success;

  _Pyload_getServerVersion_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_kill_args {
 public:

  Pyload_kill_args() {
  }

  virtual ~Pyload_kill_args() throw() {}


  bool operator == (const Pyload_kill_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_kill_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_kill_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_kill_pargs {
 public:


  virtual ~Pyload_kill_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_kill_result {
 public:

  Pyload_kill_result() {
  }

  virtual ~Pyload_kill_result() throw() {}


  bool operator == (const Pyload_kill_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_kill_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_kill_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_kill_presult {
 public:


  virtual ~Pyload_kill_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_restart_args {
 public:

  Pyload_restart_args() {
  }

  virtual ~Pyload_restart_args() throw() {}


  bool operator == (const Pyload_restart_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_restart_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_restart_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_restart_pargs {
 public:


  virtual ~Pyload_restart_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_restart_result {
 public:

  Pyload_restart_result() {
  }

  virtual ~Pyload_restart_result() throw() {}


  bool operator == (const Pyload_restart_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_restart_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_restart_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_restart_presult {
 public:


  virtual ~Pyload_restart_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_getLog_args__isset {
  _Pyload_getLog_args__isset() : offset(false) {}
  bool offset;
} _Pyload_getLog_args__isset;

class Pyload_getLog_args {
 public:

  Pyload_getLog_args() : offset(0) {
  }

  virtual ~Pyload_getLog_args() throw() {}

  int32_t offset;

  _Pyload_getLog_args__isset __isset;

  void __set_offset(const int32_t val) {
    offset = val;
  }

  bool operator == (const Pyload_getLog_args & rhs) const
  {
    if (!(offset == rhs.offset))
      return false;
    return true;
  }
  bool operator != (const Pyload_getLog_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getLog_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getLog_pargs {
 public:


  virtual ~Pyload_getLog_pargs() throw() {}

  const int32_t* offset;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getLog_result__isset {
  _Pyload_getLog_result__isset() : success(false) {}
  bool success;
} _Pyload_getLog_result__isset;

class Pyload_getLog_result {
 public:

  Pyload_getLog_result() {
  }

  virtual ~Pyload_getLog_result() throw() {}

  std::vector<std::string>  success;

  _Pyload_getLog_result__isset __isset;

  void __set_success(const std::vector<std::string> & val) {
    success = val;
  }

  bool operator == (const Pyload_getLog_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getLog_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getLog_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getLog_presult__isset {
  _Pyload_getLog_presult__isset() : success(false) {}
  bool success;
} _Pyload_getLog_presult__isset;

class Pyload_getLog_presult {
 public:


  virtual ~Pyload_getLog_presult() throw() {}

  std::vector<std::string> * success;

  _Pyload_getLog_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_isTimeDownload_args {
 public:

  Pyload_isTimeDownload_args() {
  }

  virtual ~Pyload_isTimeDownload_args() throw() {}


  bool operator == (const Pyload_isTimeDownload_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_isTimeDownload_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_isTimeDownload_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_isTimeDownload_pargs {
 public:


  virtual ~Pyload_isTimeDownload_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_isTimeDownload_result__isset {
  _Pyload_isTimeDownload_result__isset() : success(false) {}
  bool success;
} _Pyload_isTimeDownload_result__isset;

class Pyload_isTimeDownload_result {
 public:

  Pyload_isTimeDownload_result() : success(0) {
  }

  virtual ~Pyload_isTimeDownload_result() throw() {}

  bool success;

  _Pyload_isTimeDownload_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  bool operator == (const Pyload_isTimeDownload_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_isTimeDownload_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_isTimeDownload_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_isTimeDownload_presult__isset {
  _Pyload_isTimeDownload_presult__isset() : success(false) {}
  bool success;
} _Pyload_isTimeDownload_presult__isset;

class Pyload_isTimeDownload_presult {
 public:


  virtual ~Pyload_isTimeDownload_presult() throw() {}

  bool* success;

  _Pyload_isTimeDownload_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_isTimeReconnect_args {
 public:

  Pyload_isTimeReconnect_args() {
  }

  virtual ~Pyload_isTimeReconnect_args() throw() {}


  bool operator == (const Pyload_isTimeReconnect_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_isTimeReconnect_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_isTimeReconnect_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_isTimeReconnect_pargs {
 public:


  virtual ~Pyload_isTimeReconnect_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_isTimeReconnect_result__isset {
  _Pyload_isTimeReconnect_result__isset() : success(false) {}
  bool success;
} _Pyload_isTimeReconnect_result__isset;

class Pyload_isTimeReconnect_result {
 public:

  Pyload_isTimeReconnect_result() : success(0) {
  }

  virtual ~Pyload_isTimeReconnect_result() throw() {}

  bool success;

  _Pyload_isTimeReconnect_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  bool operator == (const Pyload_isTimeReconnect_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_isTimeReconnect_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_isTimeReconnect_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_isTimeReconnect_presult__isset {
  _Pyload_isTimeReconnect_presult__isset() : success(false) {}
  bool success;
} _Pyload_isTimeReconnect_presult__isset;

class Pyload_isTimeReconnect_presult {
 public:


  virtual ~Pyload_isTimeReconnect_presult() throw() {}

  bool* success;

  _Pyload_isTimeReconnect_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_toggleReconnect_args {
 public:

  Pyload_toggleReconnect_args() {
  }

  virtual ~Pyload_toggleReconnect_args() throw() {}


  bool operator == (const Pyload_toggleReconnect_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_toggleReconnect_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_toggleReconnect_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_toggleReconnect_pargs {
 public:


  virtual ~Pyload_toggleReconnect_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_toggleReconnect_result__isset {
  _Pyload_toggleReconnect_result__isset() : success(false) {}
  bool success;
} _Pyload_toggleReconnect_result__isset;

class Pyload_toggleReconnect_result {
 public:

  Pyload_toggleReconnect_result() : success(0) {
  }

  virtual ~Pyload_toggleReconnect_result() throw() {}

  bool success;

  _Pyload_toggleReconnect_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  bool operator == (const Pyload_toggleReconnect_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_toggleReconnect_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_toggleReconnect_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_toggleReconnect_presult__isset {
  _Pyload_toggleReconnect_presult__isset() : success(false) {}
  bool success;
} _Pyload_toggleReconnect_presult__isset;

class Pyload_toggleReconnect_presult {
 public:


  virtual ~Pyload_toggleReconnect_presult() throw() {}

  bool* success;

  _Pyload_toggleReconnect_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_generatePackages_args__isset {
  _Pyload_generatePackages_args__isset() : links(false) {}
  bool links;
} _Pyload_generatePackages_args__isset;

class Pyload_generatePackages_args {
 public:

  Pyload_generatePackages_args() {
  }

  virtual ~Pyload_generatePackages_args() throw() {}

  LinkList links;

  _Pyload_generatePackages_args__isset __isset;

  void __set_links(const LinkList& val) {
    links = val;
  }

  bool operator == (const Pyload_generatePackages_args & rhs) const
  {
    if (!(links == rhs.links))
      return false;
    return true;
  }
  bool operator != (const Pyload_generatePackages_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_generatePackages_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_generatePackages_pargs {
 public:


  virtual ~Pyload_generatePackages_pargs() throw() {}

  const LinkList* links;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_generatePackages_result__isset {
  _Pyload_generatePackages_result__isset() : success(false) {}
  bool success;
} _Pyload_generatePackages_result__isset;

class Pyload_generatePackages_result {
 public:

  Pyload_generatePackages_result() {
  }

  virtual ~Pyload_generatePackages_result() throw() {}

  std::map<std::string, LinkList>  success;

  _Pyload_generatePackages_result__isset __isset;

  void __set_success(const std::map<std::string, LinkList> & val) {
    success = val;
  }

  bool operator == (const Pyload_generatePackages_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_generatePackages_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_generatePackages_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_generatePackages_presult__isset {
  _Pyload_generatePackages_presult__isset() : success(false) {}
  bool success;
} _Pyload_generatePackages_presult__isset;

class Pyload_generatePackages_presult {
 public:


  virtual ~Pyload_generatePackages_presult() throw() {}

  std::map<std::string, LinkList> * success;

  _Pyload_generatePackages_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_checkURLs_args__isset {
  _Pyload_checkURLs_args__isset() : urls(false) {}
  bool urls;
} _Pyload_checkURLs_args__isset;

class Pyload_checkURLs_args {
 public:

  Pyload_checkURLs_args() {
  }

  virtual ~Pyload_checkURLs_args() throw() {}

  LinkList urls;

  _Pyload_checkURLs_args__isset __isset;

  void __set_urls(const LinkList& val) {
    urls = val;
  }

  bool operator == (const Pyload_checkURLs_args & rhs) const
  {
    if (!(urls == rhs.urls))
      return false;
    return true;
  }
  bool operator != (const Pyload_checkURLs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_checkURLs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_checkURLs_pargs {
 public:


  virtual ~Pyload_checkURLs_pargs() throw() {}

  const LinkList* urls;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_checkURLs_result__isset {
  _Pyload_checkURLs_result__isset() : success(false) {}
  bool success;
} _Pyload_checkURLs_result__isset;

class Pyload_checkURLs_result {
 public:

  Pyload_checkURLs_result() {
  }

  virtual ~Pyload_checkURLs_result() throw() {}

  std::map<PluginName, LinkList>  success;

  _Pyload_checkURLs_result__isset __isset;

  void __set_success(const std::map<PluginName, LinkList> & val) {
    success = val;
  }

  bool operator == (const Pyload_checkURLs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_checkURLs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_checkURLs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_checkURLs_presult__isset {
  _Pyload_checkURLs_presult__isset() : success(false) {}
  bool success;
} _Pyload_checkURLs_presult__isset;

class Pyload_checkURLs_presult {
 public:


  virtual ~Pyload_checkURLs_presult() throw() {}

  std::map<PluginName, LinkList> * success;

  _Pyload_checkURLs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_parseURLs_args__isset {
  _Pyload_parseURLs_args__isset() : html(false) {}
  bool html;
} _Pyload_parseURLs_args__isset;

class Pyload_parseURLs_args {
 public:

  Pyload_parseURLs_args() : html("") {
  }

  virtual ~Pyload_parseURLs_args() throw() {}

  std::string html;

  _Pyload_parseURLs_args__isset __isset;

  void __set_html(const std::string& val) {
    html = val;
  }

  bool operator == (const Pyload_parseURLs_args & rhs) const
  {
    if (!(html == rhs.html))
      return false;
    return true;
  }
  bool operator != (const Pyload_parseURLs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_parseURLs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_parseURLs_pargs {
 public:


  virtual ~Pyload_parseURLs_pargs() throw() {}

  const std::string* html;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_parseURLs_result__isset {
  _Pyload_parseURLs_result__isset() : success(false) {}
  bool success;
} _Pyload_parseURLs_result__isset;

class Pyload_parseURLs_result {
 public:

  Pyload_parseURLs_result() {
  }

  virtual ~Pyload_parseURLs_result() throw() {}

  std::map<PluginName, LinkList>  success;

  _Pyload_parseURLs_result__isset __isset;

  void __set_success(const std::map<PluginName, LinkList> & val) {
    success = val;
  }

  bool operator == (const Pyload_parseURLs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_parseURLs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_parseURLs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_parseURLs_presult__isset {
  _Pyload_parseURLs_presult__isset() : success(false) {}
  bool success;
} _Pyload_parseURLs_presult__isset;

class Pyload_parseURLs_presult {
 public:


  virtual ~Pyload_parseURLs_presult() throw() {}

  std::map<PluginName, LinkList> * success;

  _Pyload_parseURLs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_checkOnlineStatus_args__isset {
  _Pyload_checkOnlineStatus_args__isset() : urls(false) {}
  bool urls;
} _Pyload_checkOnlineStatus_args__isset;

class Pyload_checkOnlineStatus_args {
 public:

  Pyload_checkOnlineStatus_args() {
  }

  virtual ~Pyload_checkOnlineStatus_args() throw() {}

  LinkList urls;

  _Pyload_checkOnlineStatus_args__isset __isset;

  void __set_urls(const LinkList& val) {
    urls = val;
  }

  bool operator == (const Pyload_checkOnlineStatus_args & rhs) const
  {
    if (!(urls == rhs.urls))
      return false;
    return true;
  }
  bool operator != (const Pyload_checkOnlineStatus_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_checkOnlineStatus_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_checkOnlineStatus_pargs {
 public:


  virtual ~Pyload_checkOnlineStatus_pargs() throw() {}

  const LinkList* urls;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_checkOnlineStatus_result__isset {
  _Pyload_checkOnlineStatus_result__isset() : success(false) {}
  bool success;
} _Pyload_checkOnlineStatus_result__isset;

class Pyload_checkOnlineStatus_result {
 public:

  Pyload_checkOnlineStatus_result() {
  }

  virtual ~Pyload_checkOnlineStatus_result() throw() {}

  OnlineCheck success;

  _Pyload_checkOnlineStatus_result__isset __isset;

  void __set_success(const OnlineCheck& val) {
    success = val;
  }

  bool operator == (const Pyload_checkOnlineStatus_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_checkOnlineStatus_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_checkOnlineStatus_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_checkOnlineStatus_presult__isset {
  _Pyload_checkOnlineStatus_presult__isset() : success(false) {}
  bool success;
} _Pyload_checkOnlineStatus_presult__isset;

class Pyload_checkOnlineStatus_presult {
 public:


  virtual ~Pyload_checkOnlineStatus_presult() throw() {}

  OnlineCheck* success;

  _Pyload_checkOnlineStatus_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_checkOnlineStatusContainer_args__isset {
  _Pyload_checkOnlineStatusContainer_args__isset() : urls(false), filename(false), data(false) {}
  bool urls;
  bool filename;
  bool data;
} _Pyload_checkOnlineStatusContainer_args__isset;

class Pyload_checkOnlineStatusContainer_args {
 public:

  Pyload_checkOnlineStatusContainer_args() : filename(""), data("") {
  }

  virtual ~Pyload_checkOnlineStatusContainer_args() throw() {}

  LinkList urls;
  std::string filename;
  std::string data;

  _Pyload_checkOnlineStatusContainer_args__isset __isset;

  void __set_urls(const LinkList& val) {
    urls = val;
  }

  void __set_filename(const std::string& val) {
    filename = val;
  }

  void __set_data(const std::string& val) {
    data = val;
  }

  bool operator == (const Pyload_checkOnlineStatusContainer_args & rhs) const
  {
    if (!(urls == rhs.urls))
      return false;
    if (!(filename == rhs.filename))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const Pyload_checkOnlineStatusContainer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_checkOnlineStatusContainer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_checkOnlineStatusContainer_pargs {
 public:


  virtual ~Pyload_checkOnlineStatusContainer_pargs() throw() {}

  const LinkList* urls;
  const std::string* filename;
  const std::string* data;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_checkOnlineStatusContainer_result__isset {
  _Pyload_checkOnlineStatusContainer_result__isset() : success(false) {}
  bool success;
} _Pyload_checkOnlineStatusContainer_result__isset;

class Pyload_checkOnlineStatusContainer_result {
 public:

  Pyload_checkOnlineStatusContainer_result() {
  }

  virtual ~Pyload_checkOnlineStatusContainer_result() throw() {}

  OnlineCheck success;

  _Pyload_checkOnlineStatusContainer_result__isset __isset;

  void __set_success(const OnlineCheck& val) {
    success = val;
  }

  bool operator == (const Pyload_checkOnlineStatusContainer_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_checkOnlineStatusContainer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_checkOnlineStatusContainer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_checkOnlineStatusContainer_presult__isset {
  _Pyload_checkOnlineStatusContainer_presult__isset() : success(false) {}
  bool success;
} _Pyload_checkOnlineStatusContainer_presult__isset;

class Pyload_checkOnlineStatusContainer_presult {
 public:


  virtual ~Pyload_checkOnlineStatusContainer_presult() throw() {}

  OnlineCheck* success;

  _Pyload_checkOnlineStatusContainer_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_pollResults_args__isset {
  _Pyload_pollResults_args__isset() : rid(false) {}
  bool rid;
} _Pyload_pollResults_args__isset;

class Pyload_pollResults_args {
 public:

  Pyload_pollResults_args() : rid(0) {
  }

  virtual ~Pyload_pollResults_args() throw() {}

  ResultID rid;

  _Pyload_pollResults_args__isset __isset;

  void __set_rid(const ResultID val) {
    rid = val;
  }

  bool operator == (const Pyload_pollResults_args & rhs) const
  {
    if (!(rid == rhs.rid))
      return false;
    return true;
  }
  bool operator != (const Pyload_pollResults_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_pollResults_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_pollResults_pargs {
 public:


  virtual ~Pyload_pollResults_pargs() throw() {}

  const ResultID* rid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_pollResults_result__isset {
  _Pyload_pollResults_result__isset() : success(false) {}
  bool success;
} _Pyload_pollResults_result__isset;

class Pyload_pollResults_result {
 public:

  Pyload_pollResults_result() {
  }

  virtual ~Pyload_pollResults_result() throw() {}

  OnlineCheck success;

  _Pyload_pollResults_result__isset __isset;

  void __set_success(const OnlineCheck& val) {
    success = val;
  }

  bool operator == (const Pyload_pollResults_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_pollResults_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_pollResults_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_pollResults_presult__isset {
  _Pyload_pollResults_presult__isset() : success(false) {}
  bool success;
} _Pyload_pollResults_presult__isset;

class Pyload_pollResults_presult {
 public:


  virtual ~Pyload_pollResults_presult() throw() {}

  OnlineCheck* success;

  _Pyload_pollResults_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_statusDownloads_args {
 public:

  Pyload_statusDownloads_args() {
  }

  virtual ~Pyload_statusDownloads_args() throw() {}


  bool operator == (const Pyload_statusDownloads_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_statusDownloads_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_statusDownloads_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_statusDownloads_pargs {
 public:


  virtual ~Pyload_statusDownloads_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_statusDownloads_result__isset {
  _Pyload_statusDownloads_result__isset() : success(false) {}
  bool success;
} _Pyload_statusDownloads_result__isset;

class Pyload_statusDownloads_result {
 public:

  Pyload_statusDownloads_result() {
  }

  virtual ~Pyload_statusDownloads_result() throw() {}

  std::vector<DownloadInfo>  success;

  _Pyload_statusDownloads_result__isset __isset;

  void __set_success(const std::vector<DownloadInfo> & val) {
    success = val;
  }

  bool operator == (const Pyload_statusDownloads_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_statusDownloads_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_statusDownloads_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_statusDownloads_presult__isset {
  _Pyload_statusDownloads_presult__isset() : success(false) {}
  bool success;
} _Pyload_statusDownloads_presult__isset;

class Pyload_statusDownloads_presult {
 public:


  virtual ~Pyload_statusDownloads_presult() throw() {}

  std::vector<DownloadInfo> * success;

  _Pyload_statusDownloads_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_getPackageData_args__isset {
  _Pyload_getPackageData_args__isset() : pid(false) {}
  bool pid;
} _Pyload_getPackageData_args__isset;

class Pyload_getPackageData_args {
 public:

  Pyload_getPackageData_args() : pid(0) {
  }

  virtual ~Pyload_getPackageData_args() throw() {}

  PackageID pid;

  _Pyload_getPackageData_args__isset __isset;

  void __set_pid(const PackageID val) {
    pid = val;
  }

  bool operator == (const Pyload_getPackageData_args & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    return true;
  }
  bool operator != (const Pyload_getPackageData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getPackageData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getPackageData_pargs {
 public:


  virtual ~Pyload_getPackageData_pargs() throw() {}

  const PackageID* pid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getPackageData_result__isset {
  _Pyload_getPackageData_result__isset() : success(false), e(false) {}
  bool success;
  bool e;
} _Pyload_getPackageData_result__isset;

class Pyload_getPackageData_result {
 public:

  Pyload_getPackageData_result() {
  }

  virtual ~Pyload_getPackageData_result() throw() {}

  PackageData success;
  PackageDoesNotExists e;

  _Pyload_getPackageData_result__isset __isset;

  void __set_success(const PackageData& val) {
    success = val;
  }

  void __set_e(const PackageDoesNotExists& val) {
    e = val;
  }

  bool operator == (const Pyload_getPackageData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pyload_getPackageData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getPackageData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getPackageData_presult__isset {
  _Pyload_getPackageData_presult__isset() : success(false), e(false) {}
  bool success;
  bool e;
} _Pyload_getPackageData_presult__isset;

class Pyload_getPackageData_presult {
 public:


  virtual ~Pyload_getPackageData_presult() throw() {}

  PackageData* success;
  PackageDoesNotExists e;

  _Pyload_getPackageData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_getPackageInfo_args__isset {
  _Pyload_getPackageInfo_args__isset() : pid(false) {}
  bool pid;
} _Pyload_getPackageInfo_args__isset;

class Pyload_getPackageInfo_args {
 public:

  Pyload_getPackageInfo_args() : pid(0) {
  }

  virtual ~Pyload_getPackageInfo_args() throw() {}

  PackageID pid;

  _Pyload_getPackageInfo_args__isset __isset;

  void __set_pid(const PackageID val) {
    pid = val;
  }

  bool operator == (const Pyload_getPackageInfo_args & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    return true;
  }
  bool operator != (const Pyload_getPackageInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getPackageInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getPackageInfo_pargs {
 public:


  virtual ~Pyload_getPackageInfo_pargs() throw() {}

  const PackageID* pid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getPackageInfo_result__isset {
  _Pyload_getPackageInfo_result__isset() : success(false), e(false) {}
  bool success;
  bool e;
} _Pyload_getPackageInfo_result__isset;

class Pyload_getPackageInfo_result {
 public:

  Pyload_getPackageInfo_result() {
  }

  virtual ~Pyload_getPackageInfo_result() throw() {}

  PackageData success;
  PackageDoesNotExists e;

  _Pyload_getPackageInfo_result__isset __isset;

  void __set_success(const PackageData& val) {
    success = val;
  }

  void __set_e(const PackageDoesNotExists& val) {
    e = val;
  }

  bool operator == (const Pyload_getPackageInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pyload_getPackageInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getPackageInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getPackageInfo_presult__isset {
  _Pyload_getPackageInfo_presult__isset() : success(false), e(false) {}
  bool success;
  bool e;
} _Pyload_getPackageInfo_presult__isset;

class Pyload_getPackageInfo_presult {
 public:


  virtual ~Pyload_getPackageInfo_presult() throw() {}

  PackageData* success;
  PackageDoesNotExists e;

  _Pyload_getPackageInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_getFileData_args__isset {
  _Pyload_getFileData_args__isset() : fid(false) {}
  bool fid;
} _Pyload_getFileData_args__isset;

class Pyload_getFileData_args {
 public:

  Pyload_getFileData_args() : fid(0) {
  }

  virtual ~Pyload_getFileData_args() throw() {}

  FileID fid;

  _Pyload_getFileData_args__isset __isset;

  void __set_fid(const FileID val) {
    fid = val;
  }

  bool operator == (const Pyload_getFileData_args & rhs) const
  {
    if (!(fid == rhs.fid))
      return false;
    return true;
  }
  bool operator != (const Pyload_getFileData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getFileData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getFileData_pargs {
 public:


  virtual ~Pyload_getFileData_pargs() throw() {}

  const FileID* fid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getFileData_result__isset {
  _Pyload_getFileData_result__isset() : success(false), e(false) {}
  bool success;
  bool e;
} _Pyload_getFileData_result__isset;

class Pyload_getFileData_result {
 public:

  Pyload_getFileData_result() {
  }

  virtual ~Pyload_getFileData_result() throw() {}

  FileData success;
  FileDoesNotExists e;

  _Pyload_getFileData_result__isset __isset;

  void __set_success(const FileData& val) {
    success = val;
  }

  void __set_e(const FileDoesNotExists& val) {
    e = val;
  }

  bool operator == (const Pyload_getFileData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pyload_getFileData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getFileData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getFileData_presult__isset {
  _Pyload_getFileData_presult__isset() : success(false), e(false) {}
  bool success;
  bool e;
} _Pyload_getFileData_presult__isset;

class Pyload_getFileData_presult {
 public:


  virtual ~Pyload_getFileData_presult() throw() {}

  FileData* success;
  FileDoesNotExists e;

  _Pyload_getFileData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_getQueue_args {
 public:

  Pyload_getQueue_args() {
  }

  virtual ~Pyload_getQueue_args() throw() {}


  bool operator == (const Pyload_getQueue_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_getQueue_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getQueue_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getQueue_pargs {
 public:


  virtual ~Pyload_getQueue_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getQueue_result__isset {
  _Pyload_getQueue_result__isset() : success(false) {}
  bool success;
} _Pyload_getQueue_result__isset;

class Pyload_getQueue_result {
 public:

  Pyload_getQueue_result() {
  }

  virtual ~Pyload_getQueue_result() throw() {}

  std::vector<PackageData>  success;

  _Pyload_getQueue_result__isset __isset;

  void __set_success(const std::vector<PackageData> & val) {
    success = val;
  }

  bool operator == (const Pyload_getQueue_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getQueue_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getQueue_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getQueue_presult__isset {
  _Pyload_getQueue_presult__isset() : success(false) {}
  bool success;
} _Pyload_getQueue_presult__isset;

class Pyload_getQueue_presult {
 public:


  virtual ~Pyload_getQueue_presult() throw() {}

  std::vector<PackageData> * success;

  _Pyload_getQueue_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_getCollector_args {
 public:

  Pyload_getCollector_args() {
  }

  virtual ~Pyload_getCollector_args() throw() {}


  bool operator == (const Pyload_getCollector_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_getCollector_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getCollector_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getCollector_pargs {
 public:


  virtual ~Pyload_getCollector_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getCollector_result__isset {
  _Pyload_getCollector_result__isset() : success(false) {}
  bool success;
} _Pyload_getCollector_result__isset;

class Pyload_getCollector_result {
 public:

  Pyload_getCollector_result() {
  }

  virtual ~Pyload_getCollector_result() throw() {}

  std::vector<PackageData>  success;

  _Pyload_getCollector_result__isset __isset;

  void __set_success(const std::vector<PackageData> & val) {
    success = val;
  }

  bool operator == (const Pyload_getCollector_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getCollector_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getCollector_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getCollector_presult__isset {
  _Pyload_getCollector_presult__isset() : success(false) {}
  bool success;
} _Pyload_getCollector_presult__isset;

class Pyload_getCollector_presult {
 public:


  virtual ~Pyload_getCollector_presult() throw() {}

  std::vector<PackageData> * success;

  _Pyload_getCollector_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_getQueueData_args {
 public:

  Pyload_getQueueData_args() {
  }

  virtual ~Pyload_getQueueData_args() throw() {}


  bool operator == (const Pyload_getQueueData_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_getQueueData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getQueueData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getQueueData_pargs {
 public:


  virtual ~Pyload_getQueueData_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getQueueData_result__isset {
  _Pyload_getQueueData_result__isset() : success(false) {}
  bool success;
} _Pyload_getQueueData_result__isset;

class Pyload_getQueueData_result {
 public:

  Pyload_getQueueData_result() {
  }

  virtual ~Pyload_getQueueData_result() throw() {}

  std::vector<PackageData>  success;

  _Pyload_getQueueData_result__isset __isset;

  void __set_success(const std::vector<PackageData> & val) {
    success = val;
  }

  bool operator == (const Pyload_getQueueData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getQueueData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getQueueData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getQueueData_presult__isset {
  _Pyload_getQueueData_presult__isset() : success(false) {}
  bool success;
} _Pyload_getQueueData_presult__isset;

class Pyload_getQueueData_presult {
 public:


  virtual ~Pyload_getQueueData_presult() throw() {}

  std::vector<PackageData> * success;

  _Pyload_getQueueData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_getCollectorData_args {
 public:

  Pyload_getCollectorData_args() {
  }

  virtual ~Pyload_getCollectorData_args() throw() {}


  bool operator == (const Pyload_getCollectorData_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_getCollectorData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getCollectorData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getCollectorData_pargs {
 public:


  virtual ~Pyload_getCollectorData_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getCollectorData_result__isset {
  _Pyload_getCollectorData_result__isset() : success(false) {}
  bool success;
} _Pyload_getCollectorData_result__isset;

class Pyload_getCollectorData_result {
 public:

  Pyload_getCollectorData_result() {
  }

  virtual ~Pyload_getCollectorData_result() throw() {}

  std::vector<PackageData>  success;

  _Pyload_getCollectorData_result__isset __isset;

  void __set_success(const std::vector<PackageData> & val) {
    success = val;
  }

  bool operator == (const Pyload_getCollectorData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getCollectorData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getCollectorData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getCollectorData_presult__isset {
  _Pyload_getCollectorData_presult__isset() : success(false) {}
  bool success;
} _Pyload_getCollectorData_presult__isset;

class Pyload_getCollectorData_presult {
 public:


  virtual ~Pyload_getCollectorData_presult() throw() {}

  std::vector<PackageData> * success;

  _Pyload_getCollectorData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_getPackageOrder_args__isset {
  _Pyload_getPackageOrder_args__isset() : destination(false) {}
  bool destination;
} _Pyload_getPackageOrder_args__isset;

class Pyload_getPackageOrder_args {
 public:

  Pyload_getPackageOrder_args() {
  }

  virtual ~Pyload_getPackageOrder_args() throw() {}

  Destination::type destination;

  _Pyload_getPackageOrder_args__isset __isset;

  void __set_destination(const Destination::type val) {
    destination = val;
  }

  bool operator == (const Pyload_getPackageOrder_args & rhs) const
  {
    if (!(destination == rhs.destination))
      return false;
    return true;
  }
  bool operator != (const Pyload_getPackageOrder_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getPackageOrder_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getPackageOrder_pargs {
 public:


  virtual ~Pyload_getPackageOrder_pargs() throw() {}

  const Destination::type* destination;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getPackageOrder_result__isset {
  _Pyload_getPackageOrder_result__isset() : success(false) {}
  bool success;
} _Pyload_getPackageOrder_result__isset;

class Pyload_getPackageOrder_result {
 public:

  Pyload_getPackageOrder_result() {
  }

  virtual ~Pyload_getPackageOrder_result() throw() {}

  std::map<int16_t, PackageID>  success;

  _Pyload_getPackageOrder_result__isset __isset;

  void __set_success(const std::map<int16_t, PackageID> & val) {
    success = val;
  }

  bool operator == (const Pyload_getPackageOrder_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getPackageOrder_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getPackageOrder_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getPackageOrder_presult__isset {
  _Pyload_getPackageOrder_presult__isset() : success(false) {}
  bool success;
} _Pyload_getPackageOrder_presult__isset;

class Pyload_getPackageOrder_presult {
 public:


  virtual ~Pyload_getPackageOrder_presult() throw() {}

  std::map<int16_t, PackageID> * success;

  _Pyload_getPackageOrder_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_getFileOrder_args__isset {
  _Pyload_getFileOrder_args__isset() : pid(false) {}
  bool pid;
} _Pyload_getFileOrder_args__isset;

class Pyload_getFileOrder_args {
 public:

  Pyload_getFileOrder_args() : pid(0) {
  }

  virtual ~Pyload_getFileOrder_args() throw() {}

  PackageID pid;

  _Pyload_getFileOrder_args__isset __isset;

  void __set_pid(const PackageID val) {
    pid = val;
  }

  bool operator == (const Pyload_getFileOrder_args & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    return true;
  }
  bool operator != (const Pyload_getFileOrder_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getFileOrder_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getFileOrder_pargs {
 public:


  virtual ~Pyload_getFileOrder_pargs() throw() {}

  const PackageID* pid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getFileOrder_result__isset {
  _Pyload_getFileOrder_result__isset() : success(false) {}
  bool success;
} _Pyload_getFileOrder_result__isset;

class Pyload_getFileOrder_result {
 public:

  Pyload_getFileOrder_result() {
  }

  virtual ~Pyload_getFileOrder_result() throw() {}

  std::map<int16_t, FileID>  success;

  _Pyload_getFileOrder_result__isset __isset;

  void __set_success(const std::map<int16_t, FileID> & val) {
    success = val;
  }

  bool operator == (const Pyload_getFileOrder_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getFileOrder_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getFileOrder_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getFileOrder_presult__isset {
  _Pyload_getFileOrder_presult__isset() : success(false) {}
  bool success;
} _Pyload_getFileOrder_presult__isset;

class Pyload_getFileOrder_presult {
 public:


  virtual ~Pyload_getFileOrder_presult() throw() {}

  std::map<int16_t, FileID> * success;

  _Pyload_getFileOrder_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_generateAndAddPackages_args__isset {
  _Pyload_generateAndAddPackages_args__isset() : links(false), dest(false) {}
  bool links;
  bool dest;
} _Pyload_generateAndAddPackages_args__isset;

class Pyload_generateAndAddPackages_args {
 public:

  Pyload_generateAndAddPackages_args() {
  }

  virtual ~Pyload_generateAndAddPackages_args() throw() {}

  LinkList links;
  Destination::type dest;

  _Pyload_generateAndAddPackages_args__isset __isset;

  void __set_links(const LinkList& val) {
    links = val;
  }

  void __set_dest(const Destination::type val) {
    dest = val;
  }

  bool operator == (const Pyload_generateAndAddPackages_args & rhs) const
  {
    if (!(links == rhs.links))
      return false;
    if (!(dest == rhs.dest))
      return false;
    return true;
  }
  bool operator != (const Pyload_generateAndAddPackages_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_generateAndAddPackages_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_generateAndAddPackages_pargs {
 public:


  virtual ~Pyload_generateAndAddPackages_pargs() throw() {}

  const LinkList* links;
  const Destination::type* dest;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_generateAndAddPackages_result__isset {
  _Pyload_generateAndAddPackages_result__isset() : success(false) {}
  bool success;
} _Pyload_generateAndAddPackages_result__isset;

class Pyload_generateAndAddPackages_result {
 public:

  Pyload_generateAndAddPackages_result() {
  }

  virtual ~Pyload_generateAndAddPackages_result() throw() {}

  std::vector<PackageID>  success;

  _Pyload_generateAndAddPackages_result__isset __isset;

  void __set_success(const std::vector<PackageID> & val) {
    success = val;
  }

  bool operator == (const Pyload_generateAndAddPackages_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_generateAndAddPackages_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_generateAndAddPackages_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_generateAndAddPackages_presult__isset {
  _Pyload_generateAndAddPackages_presult__isset() : success(false) {}
  bool success;
} _Pyload_generateAndAddPackages_presult__isset;

class Pyload_generateAndAddPackages_presult {
 public:


  virtual ~Pyload_generateAndAddPackages_presult() throw() {}

  std::vector<PackageID> * success;

  _Pyload_generateAndAddPackages_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_addPackage_args__isset {
  _Pyload_addPackage_args__isset() : name(false), links(false), dest(false) {}
  bool name;
  bool links;
  bool dest;
} _Pyload_addPackage_args__isset;

class Pyload_addPackage_args {
 public:

  Pyload_addPackage_args() : name("") {
  }

  virtual ~Pyload_addPackage_args() throw() {}

  std::string name;
  LinkList links;
  Destination::type dest;

  _Pyload_addPackage_args__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_links(const LinkList& val) {
    links = val;
  }

  void __set_dest(const Destination::type val) {
    dest = val;
  }

  bool operator == (const Pyload_addPackage_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(links == rhs.links))
      return false;
    if (!(dest == rhs.dest))
      return false;
    return true;
  }
  bool operator != (const Pyload_addPackage_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_addPackage_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_addPackage_pargs {
 public:


  virtual ~Pyload_addPackage_pargs() throw() {}

  const std::string* name;
  const LinkList* links;
  const Destination::type* dest;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_addPackage_result__isset {
  _Pyload_addPackage_result__isset() : success(false) {}
  bool success;
} _Pyload_addPackage_result__isset;

class Pyload_addPackage_result {
 public:

  Pyload_addPackage_result() : success(0) {
  }

  virtual ~Pyload_addPackage_result() throw() {}

  PackageID success;

  _Pyload_addPackage_result__isset __isset;

  void __set_success(const PackageID val) {
    success = val;
  }

  bool operator == (const Pyload_addPackage_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_addPackage_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_addPackage_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_addPackage_presult__isset {
  _Pyload_addPackage_presult__isset() : success(false) {}
  bool success;
} _Pyload_addPackage_presult__isset;

class Pyload_addPackage_presult {
 public:


  virtual ~Pyload_addPackage_presult() throw() {}

  PackageID* success;

  _Pyload_addPackage_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_addFiles_args__isset {
  _Pyload_addFiles_args__isset() : pid(false), links(false) {}
  bool pid;
  bool links;
} _Pyload_addFiles_args__isset;

class Pyload_addFiles_args {
 public:

  Pyload_addFiles_args() : pid(0) {
  }

  virtual ~Pyload_addFiles_args() throw() {}

  PackageID pid;
  LinkList links;

  _Pyload_addFiles_args__isset __isset;

  void __set_pid(const PackageID val) {
    pid = val;
  }

  void __set_links(const LinkList& val) {
    links = val;
  }

  bool operator == (const Pyload_addFiles_args & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(links == rhs.links))
      return false;
    return true;
  }
  bool operator != (const Pyload_addFiles_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_addFiles_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_addFiles_pargs {
 public:


  virtual ~Pyload_addFiles_pargs() throw() {}

  const PackageID* pid;
  const LinkList* links;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_addFiles_result {
 public:

  Pyload_addFiles_result() {
  }

  virtual ~Pyload_addFiles_result() throw() {}


  bool operator == (const Pyload_addFiles_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_addFiles_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_addFiles_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_addFiles_presult {
 public:


  virtual ~Pyload_addFiles_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_uploadContainer_args__isset {
  _Pyload_uploadContainer_args__isset() : filename(false), data(false) {}
  bool filename;
  bool data;
} _Pyload_uploadContainer_args__isset;

class Pyload_uploadContainer_args {
 public:

  Pyload_uploadContainer_args() : filename(""), data("") {
  }

  virtual ~Pyload_uploadContainer_args() throw() {}

  std::string filename;
  std::string data;

  _Pyload_uploadContainer_args__isset __isset;

  void __set_filename(const std::string& val) {
    filename = val;
  }

  void __set_data(const std::string& val) {
    data = val;
  }

  bool operator == (const Pyload_uploadContainer_args & rhs) const
  {
    if (!(filename == rhs.filename))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const Pyload_uploadContainer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_uploadContainer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_uploadContainer_pargs {
 public:


  virtual ~Pyload_uploadContainer_pargs() throw() {}

  const std::string* filename;
  const std::string* data;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_uploadContainer_result {
 public:

  Pyload_uploadContainer_result() {
  }

  virtual ~Pyload_uploadContainer_result() throw() {}


  bool operator == (const Pyload_uploadContainer_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_uploadContainer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_uploadContainer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_uploadContainer_presult {
 public:


  virtual ~Pyload_uploadContainer_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_deleteFiles_args__isset {
  _Pyload_deleteFiles_args__isset() : fids(false) {}
  bool fids;
} _Pyload_deleteFiles_args__isset;

class Pyload_deleteFiles_args {
 public:

  Pyload_deleteFiles_args() {
  }

  virtual ~Pyload_deleteFiles_args() throw() {}

  std::vector<FileID>  fids;

  _Pyload_deleteFiles_args__isset __isset;

  void __set_fids(const std::vector<FileID> & val) {
    fids = val;
  }

  bool operator == (const Pyload_deleteFiles_args & rhs) const
  {
    if (!(fids == rhs.fids))
      return false;
    return true;
  }
  bool operator != (const Pyload_deleteFiles_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_deleteFiles_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_deleteFiles_pargs {
 public:


  virtual ~Pyload_deleteFiles_pargs() throw() {}

  const std::vector<FileID> * fids;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_deleteFiles_result {
 public:

  Pyload_deleteFiles_result() {
  }

  virtual ~Pyload_deleteFiles_result() throw() {}


  bool operator == (const Pyload_deleteFiles_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_deleteFiles_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_deleteFiles_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_deleteFiles_presult {
 public:


  virtual ~Pyload_deleteFiles_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_deletePackages_args__isset {
  _Pyload_deletePackages_args__isset() : pids(false) {}
  bool pids;
} _Pyload_deletePackages_args__isset;

class Pyload_deletePackages_args {
 public:

  Pyload_deletePackages_args() {
  }

  virtual ~Pyload_deletePackages_args() throw() {}

  std::vector<PackageID>  pids;

  _Pyload_deletePackages_args__isset __isset;

  void __set_pids(const std::vector<PackageID> & val) {
    pids = val;
  }

  bool operator == (const Pyload_deletePackages_args & rhs) const
  {
    if (!(pids == rhs.pids))
      return false;
    return true;
  }
  bool operator != (const Pyload_deletePackages_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_deletePackages_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_deletePackages_pargs {
 public:


  virtual ~Pyload_deletePackages_pargs() throw() {}

  const std::vector<PackageID> * pids;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_deletePackages_result {
 public:

  Pyload_deletePackages_result() {
  }

  virtual ~Pyload_deletePackages_result() throw() {}


  bool operator == (const Pyload_deletePackages_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_deletePackages_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_deletePackages_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_deletePackages_presult {
 public:


  virtual ~Pyload_deletePackages_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_pushToQueue_args__isset {
  _Pyload_pushToQueue_args__isset() : pid(false) {}
  bool pid;
} _Pyload_pushToQueue_args__isset;

class Pyload_pushToQueue_args {
 public:

  Pyload_pushToQueue_args() : pid(0) {
  }

  virtual ~Pyload_pushToQueue_args() throw() {}

  PackageID pid;

  _Pyload_pushToQueue_args__isset __isset;

  void __set_pid(const PackageID val) {
    pid = val;
  }

  bool operator == (const Pyload_pushToQueue_args & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    return true;
  }
  bool operator != (const Pyload_pushToQueue_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_pushToQueue_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_pushToQueue_pargs {
 public:


  virtual ~Pyload_pushToQueue_pargs() throw() {}

  const PackageID* pid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_pushToQueue_result {
 public:

  Pyload_pushToQueue_result() {
  }

  virtual ~Pyload_pushToQueue_result() throw() {}


  bool operator == (const Pyload_pushToQueue_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_pushToQueue_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_pushToQueue_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_pushToQueue_presult {
 public:


  virtual ~Pyload_pushToQueue_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_pullFromQueue_args__isset {
  _Pyload_pullFromQueue_args__isset() : pid(false) {}
  bool pid;
} _Pyload_pullFromQueue_args__isset;

class Pyload_pullFromQueue_args {
 public:

  Pyload_pullFromQueue_args() : pid(0) {
  }

  virtual ~Pyload_pullFromQueue_args() throw() {}

  PackageID pid;

  _Pyload_pullFromQueue_args__isset __isset;

  void __set_pid(const PackageID val) {
    pid = val;
  }

  bool operator == (const Pyload_pullFromQueue_args & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    return true;
  }
  bool operator != (const Pyload_pullFromQueue_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_pullFromQueue_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_pullFromQueue_pargs {
 public:


  virtual ~Pyload_pullFromQueue_pargs() throw() {}

  const PackageID* pid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_pullFromQueue_result {
 public:

  Pyload_pullFromQueue_result() {
  }

  virtual ~Pyload_pullFromQueue_result() throw() {}


  bool operator == (const Pyload_pullFromQueue_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_pullFromQueue_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_pullFromQueue_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_pullFromQueue_presult {
 public:


  virtual ~Pyload_pullFromQueue_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_restartPackage_args__isset {
  _Pyload_restartPackage_args__isset() : pid(false) {}
  bool pid;
} _Pyload_restartPackage_args__isset;

class Pyload_restartPackage_args {
 public:

  Pyload_restartPackage_args() : pid(0) {
  }

  virtual ~Pyload_restartPackage_args() throw() {}

  PackageID pid;

  _Pyload_restartPackage_args__isset __isset;

  void __set_pid(const PackageID val) {
    pid = val;
  }

  bool operator == (const Pyload_restartPackage_args & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    return true;
  }
  bool operator != (const Pyload_restartPackage_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_restartPackage_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_restartPackage_pargs {
 public:


  virtual ~Pyload_restartPackage_pargs() throw() {}

  const PackageID* pid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_restartPackage_result {
 public:

  Pyload_restartPackage_result() {
  }

  virtual ~Pyload_restartPackage_result() throw() {}


  bool operator == (const Pyload_restartPackage_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_restartPackage_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_restartPackage_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_restartPackage_presult {
 public:


  virtual ~Pyload_restartPackage_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_restartFile_args__isset {
  _Pyload_restartFile_args__isset() : fid(false) {}
  bool fid;
} _Pyload_restartFile_args__isset;

class Pyload_restartFile_args {
 public:

  Pyload_restartFile_args() : fid(0) {
  }

  virtual ~Pyload_restartFile_args() throw() {}

  FileID fid;

  _Pyload_restartFile_args__isset __isset;

  void __set_fid(const FileID val) {
    fid = val;
  }

  bool operator == (const Pyload_restartFile_args & rhs) const
  {
    if (!(fid == rhs.fid))
      return false;
    return true;
  }
  bool operator != (const Pyload_restartFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_restartFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_restartFile_pargs {
 public:


  virtual ~Pyload_restartFile_pargs() throw() {}

  const FileID* fid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_restartFile_result {
 public:

  Pyload_restartFile_result() {
  }

  virtual ~Pyload_restartFile_result() throw() {}


  bool operator == (const Pyload_restartFile_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_restartFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_restartFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_restartFile_presult {
 public:


  virtual ~Pyload_restartFile_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_recheckPackage_args__isset {
  _Pyload_recheckPackage_args__isset() : pid(false) {}
  bool pid;
} _Pyload_recheckPackage_args__isset;

class Pyload_recheckPackage_args {
 public:

  Pyload_recheckPackage_args() : pid(0) {
  }

  virtual ~Pyload_recheckPackage_args() throw() {}

  PackageID pid;

  _Pyload_recheckPackage_args__isset __isset;

  void __set_pid(const PackageID val) {
    pid = val;
  }

  bool operator == (const Pyload_recheckPackage_args & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    return true;
  }
  bool operator != (const Pyload_recheckPackage_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_recheckPackage_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_recheckPackage_pargs {
 public:


  virtual ~Pyload_recheckPackage_pargs() throw() {}

  const PackageID* pid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_recheckPackage_result {
 public:

  Pyload_recheckPackage_result() {
  }

  virtual ~Pyload_recheckPackage_result() throw() {}


  bool operator == (const Pyload_recheckPackage_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_recheckPackage_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_recheckPackage_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_recheckPackage_presult {
 public:


  virtual ~Pyload_recheckPackage_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_stopAllDownloads_args {
 public:

  Pyload_stopAllDownloads_args() {
  }

  virtual ~Pyload_stopAllDownloads_args() throw() {}


  bool operator == (const Pyload_stopAllDownloads_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_stopAllDownloads_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_stopAllDownloads_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_stopAllDownloads_pargs {
 public:


  virtual ~Pyload_stopAllDownloads_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_stopAllDownloads_result {
 public:

  Pyload_stopAllDownloads_result() {
  }

  virtual ~Pyload_stopAllDownloads_result() throw() {}


  bool operator == (const Pyload_stopAllDownloads_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_stopAllDownloads_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_stopAllDownloads_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_stopAllDownloads_presult {
 public:


  virtual ~Pyload_stopAllDownloads_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_stopDownloads_args__isset {
  _Pyload_stopDownloads_args__isset() : fids(false) {}
  bool fids;
} _Pyload_stopDownloads_args__isset;

class Pyload_stopDownloads_args {
 public:

  Pyload_stopDownloads_args() {
  }

  virtual ~Pyload_stopDownloads_args() throw() {}

  std::vector<FileID>  fids;

  _Pyload_stopDownloads_args__isset __isset;

  void __set_fids(const std::vector<FileID> & val) {
    fids = val;
  }

  bool operator == (const Pyload_stopDownloads_args & rhs) const
  {
    if (!(fids == rhs.fids))
      return false;
    return true;
  }
  bool operator != (const Pyload_stopDownloads_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_stopDownloads_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_stopDownloads_pargs {
 public:


  virtual ~Pyload_stopDownloads_pargs() throw() {}

  const std::vector<FileID> * fids;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_stopDownloads_result {
 public:

  Pyload_stopDownloads_result() {
  }

  virtual ~Pyload_stopDownloads_result() throw() {}


  bool operator == (const Pyload_stopDownloads_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_stopDownloads_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_stopDownloads_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_stopDownloads_presult {
 public:


  virtual ~Pyload_stopDownloads_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_setPackageName_args__isset {
  _Pyload_setPackageName_args__isset() : pid(false), name(false) {}
  bool pid;
  bool name;
} _Pyload_setPackageName_args__isset;

class Pyload_setPackageName_args {
 public:

  Pyload_setPackageName_args() : pid(0), name("") {
  }

  virtual ~Pyload_setPackageName_args() throw() {}

  PackageID pid;
  std::string name;

  _Pyload_setPackageName_args__isset __isset;

  void __set_pid(const PackageID val) {
    pid = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  bool operator == (const Pyload_setPackageName_args & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Pyload_setPackageName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_setPackageName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_setPackageName_pargs {
 public:


  virtual ~Pyload_setPackageName_pargs() throw() {}

  const PackageID* pid;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_setPackageName_result {
 public:

  Pyload_setPackageName_result() {
  }

  virtual ~Pyload_setPackageName_result() throw() {}


  bool operator == (const Pyload_setPackageName_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_setPackageName_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_setPackageName_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_setPackageName_presult {
 public:


  virtual ~Pyload_setPackageName_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_movePackage_args__isset {
  _Pyload_movePackage_args__isset() : destination(false), pid(false) {}
  bool destination;
  bool pid;
} _Pyload_movePackage_args__isset;

class Pyload_movePackage_args {
 public:

  Pyload_movePackage_args() : pid(0) {
  }

  virtual ~Pyload_movePackage_args() throw() {}

  Destination::type destination;
  PackageID pid;

  _Pyload_movePackage_args__isset __isset;

  void __set_destination(const Destination::type val) {
    destination = val;
  }

  void __set_pid(const PackageID val) {
    pid = val;
  }

  bool operator == (const Pyload_movePackage_args & rhs) const
  {
    if (!(destination == rhs.destination))
      return false;
    if (!(pid == rhs.pid))
      return false;
    return true;
  }
  bool operator != (const Pyload_movePackage_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_movePackage_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_movePackage_pargs {
 public:


  virtual ~Pyload_movePackage_pargs() throw() {}

  const Destination::type* destination;
  const PackageID* pid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_movePackage_result {
 public:

  Pyload_movePackage_result() {
  }

  virtual ~Pyload_movePackage_result() throw() {}


  bool operator == (const Pyload_movePackage_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_movePackage_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_movePackage_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_movePackage_presult {
 public:


  virtual ~Pyload_movePackage_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_moveFiles_args__isset {
  _Pyload_moveFiles_args__isset() : fids(false), pid(false) {}
  bool fids;
  bool pid;
} _Pyload_moveFiles_args__isset;

class Pyload_moveFiles_args {
 public:

  Pyload_moveFiles_args() : pid(0) {
  }

  virtual ~Pyload_moveFiles_args() throw() {}

  std::vector<FileID>  fids;
  PackageID pid;

  _Pyload_moveFiles_args__isset __isset;

  void __set_fids(const std::vector<FileID> & val) {
    fids = val;
  }

  void __set_pid(const PackageID val) {
    pid = val;
  }

  bool operator == (const Pyload_moveFiles_args & rhs) const
  {
    if (!(fids == rhs.fids))
      return false;
    if (!(pid == rhs.pid))
      return false;
    return true;
  }
  bool operator != (const Pyload_moveFiles_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_moveFiles_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_moveFiles_pargs {
 public:


  virtual ~Pyload_moveFiles_pargs() throw() {}

  const std::vector<FileID> * fids;
  const PackageID* pid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_moveFiles_result {
 public:

  Pyload_moveFiles_result() {
  }

  virtual ~Pyload_moveFiles_result() throw() {}


  bool operator == (const Pyload_moveFiles_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_moveFiles_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_moveFiles_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_moveFiles_presult {
 public:


  virtual ~Pyload_moveFiles_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_orderPackage_args__isset {
  _Pyload_orderPackage_args__isset() : pid(false), position(false) {}
  bool pid;
  bool position;
} _Pyload_orderPackage_args__isset;

class Pyload_orderPackage_args {
 public:

  Pyload_orderPackage_args() : pid(0), position(0) {
  }

  virtual ~Pyload_orderPackage_args() throw() {}

  PackageID pid;
  int16_t position;

  _Pyload_orderPackage_args__isset __isset;

  void __set_pid(const PackageID val) {
    pid = val;
  }

  void __set_position(const int16_t val) {
    position = val;
  }

  bool operator == (const Pyload_orderPackage_args & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(position == rhs.position))
      return false;
    return true;
  }
  bool operator != (const Pyload_orderPackage_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_orderPackage_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_orderPackage_pargs {
 public:


  virtual ~Pyload_orderPackage_pargs() throw() {}

  const PackageID* pid;
  const int16_t* position;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_orderPackage_result {
 public:

  Pyload_orderPackage_result() {
  }

  virtual ~Pyload_orderPackage_result() throw() {}


  bool operator == (const Pyload_orderPackage_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_orderPackage_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_orderPackage_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_orderPackage_presult {
 public:


  virtual ~Pyload_orderPackage_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_orderFile_args__isset {
  _Pyload_orderFile_args__isset() : fid(false), position(false) {}
  bool fid;
  bool position;
} _Pyload_orderFile_args__isset;

class Pyload_orderFile_args {
 public:

  Pyload_orderFile_args() : fid(0), position(0) {
  }

  virtual ~Pyload_orderFile_args() throw() {}

  FileID fid;
  int16_t position;

  _Pyload_orderFile_args__isset __isset;

  void __set_fid(const FileID val) {
    fid = val;
  }

  void __set_position(const int16_t val) {
    position = val;
  }

  bool operator == (const Pyload_orderFile_args & rhs) const
  {
    if (!(fid == rhs.fid))
      return false;
    if (!(position == rhs.position))
      return false;
    return true;
  }
  bool operator != (const Pyload_orderFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_orderFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_orderFile_pargs {
 public:


  virtual ~Pyload_orderFile_pargs() throw() {}

  const FileID* fid;
  const int16_t* position;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_orderFile_result {
 public:

  Pyload_orderFile_result() {
  }

  virtual ~Pyload_orderFile_result() throw() {}


  bool operator == (const Pyload_orderFile_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_orderFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_orderFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_orderFile_presult {
 public:


  virtual ~Pyload_orderFile_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_setPackageData_args__isset {
  _Pyload_setPackageData_args__isset() : pid(false), data(false) {}
  bool pid;
  bool data;
} _Pyload_setPackageData_args__isset;

class Pyload_setPackageData_args {
 public:

  Pyload_setPackageData_args() : pid(0) {
  }

  virtual ~Pyload_setPackageData_args() throw() {}

  PackageID pid;
  std::map<std::string, std::string>  data;

  _Pyload_setPackageData_args__isset __isset;

  void __set_pid(const PackageID val) {
    pid = val;
  }

  void __set_data(const std::map<std::string, std::string> & val) {
    data = val;
  }

  bool operator == (const Pyload_setPackageData_args & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const Pyload_setPackageData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_setPackageData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_setPackageData_pargs {
 public:


  virtual ~Pyload_setPackageData_pargs() throw() {}

  const PackageID* pid;
  const std::map<std::string, std::string> * data;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_setPackageData_result__isset {
  _Pyload_setPackageData_result__isset() : e(false) {}
  bool e;
} _Pyload_setPackageData_result__isset;

class Pyload_setPackageData_result {
 public:

  Pyload_setPackageData_result() {
  }

  virtual ~Pyload_setPackageData_result() throw() {}

  PackageDoesNotExists e;

  _Pyload_setPackageData_result__isset __isset;

  void __set_e(const PackageDoesNotExists& val) {
    e = val;
  }

  bool operator == (const Pyload_setPackageData_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pyload_setPackageData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_setPackageData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_setPackageData_presult__isset {
  _Pyload_setPackageData_presult__isset() : e(false) {}
  bool e;
} _Pyload_setPackageData_presult__isset;

class Pyload_setPackageData_presult {
 public:


  virtual ~Pyload_setPackageData_presult() throw() {}

  PackageDoesNotExists e;

  _Pyload_setPackageData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_deleteFinished_args {
 public:

  Pyload_deleteFinished_args() {
  }

  virtual ~Pyload_deleteFinished_args() throw() {}


  bool operator == (const Pyload_deleteFinished_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_deleteFinished_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_deleteFinished_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_deleteFinished_pargs {
 public:


  virtual ~Pyload_deleteFinished_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_deleteFinished_result {
 public:

  Pyload_deleteFinished_result() {
  }

  virtual ~Pyload_deleteFinished_result() throw() {}


  bool operator == (const Pyload_deleteFinished_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_deleteFinished_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_deleteFinished_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_deleteFinished_presult {
 public:


  virtual ~Pyload_deleteFinished_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_restartFailed_args {
 public:

  Pyload_restartFailed_args() {
  }

  virtual ~Pyload_restartFailed_args() throw() {}


  bool operator == (const Pyload_restartFailed_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_restartFailed_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_restartFailed_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_restartFailed_pargs {
 public:


  virtual ~Pyload_restartFailed_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_restartFailed_result {
 public:

  Pyload_restartFailed_result() {
  }

  virtual ~Pyload_restartFailed_result() throw() {}


  bool operator == (const Pyload_restartFailed_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_restartFailed_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_restartFailed_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_restartFailed_presult {
 public:


  virtual ~Pyload_restartFailed_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_isCaptchaWaiting_args {
 public:

  Pyload_isCaptchaWaiting_args() {
  }

  virtual ~Pyload_isCaptchaWaiting_args() throw() {}


  bool operator == (const Pyload_isCaptchaWaiting_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_isCaptchaWaiting_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_isCaptchaWaiting_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_isCaptchaWaiting_pargs {
 public:


  virtual ~Pyload_isCaptchaWaiting_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_isCaptchaWaiting_result__isset {
  _Pyload_isCaptchaWaiting_result__isset() : success(false) {}
  bool success;
} _Pyload_isCaptchaWaiting_result__isset;

class Pyload_isCaptchaWaiting_result {
 public:

  Pyload_isCaptchaWaiting_result() : success(0) {
  }

  virtual ~Pyload_isCaptchaWaiting_result() throw() {}

  bool success;

  _Pyload_isCaptchaWaiting_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  bool operator == (const Pyload_isCaptchaWaiting_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_isCaptchaWaiting_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_isCaptchaWaiting_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_isCaptchaWaiting_presult__isset {
  _Pyload_isCaptchaWaiting_presult__isset() : success(false) {}
  bool success;
} _Pyload_isCaptchaWaiting_presult__isset;

class Pyload_isCaptchaWaiting_presult {
 public:


  virtual ~Pyload_isCaptchaWaiting_presult() throw() {}

  bool* success;

  _Pyload_isCaptchaWaiting_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_getCaptchaTask_args__isset {
  _Pyload_getCaptchaTask_args__isset() : exclusive(false) {}
  bool exclusive;
} _Pyload_getCaptchaTask_args__isset;

class Pyload_getCaptchaTask_args {
 public:

  Pyload_getCaptchaTask_args() : exclusive(0) {
  }

  virtual ~Pyload_getCaptchaTask_args() throw() {}

  bool exclusive;

  _Pyload_getCaptchaTask_args__isset __isset;

  void __set_exclusive(const bool val) {
    exclusive = val;
  }

  bool operator == (const Pyload_getCaptchaTask_args & rhs) const
  {
    if (!(exclusive == rhs.exclusive))
      return false;
    return true;
  }
  bool operator != (const Pyload_getCaptchaTask_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getCaptchaTask_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getCaptchaTask_pargs {
 public:


  virtual ~Pyload_getCaptchaTask_pargs() throw() {}

  const bool* exclusive;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getCaptchaTask_result__isset {
  _Pyload_getCaptchaTask_result__isset() : success(false) {}
  bool success;
} _Pyload_getCaptchaTask_result__isset;

class Pyload_getCaptchaTask_result {
 public:

  Pyload_getCaptchaTask_result() {
  }

  virtual ~Pyload_getCaptchaTask_result() throw() {}

  CaptchaTask success;

  _Pyload_getCaptchaTask_result__isset __isset;

  void __set_success(const CaptchaTask& val) {
    success = val;
  }

  bool operator == (const Pyload_getCaptchaTask_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getCaptchaTask_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getCaptchaTask_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getCaptchaTask_presult__isset {
  _Pyload_getCaptchaTask_presult__isset() : success(false) {}
  bool success;
} _Pyload_getCaptchaTask_presult__isset;

class Pyload_getCaptchaTask_presult {
 public:


  virtual ~Pyload_getCaptchaTask_presult() throw() {}

  CaptchaTask* success;

  _Pyload_getCaptchaTask_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_getCaptchaTaskStatus_args__isset {
  _Pyload_getCaptchaTaskStatus_args__isset() : tid(false) {}
  bool tid;
} _Pyload_getCaptchaTaskStatus_args__isset;

class Pyload_getCaptchaTaskStatus_args {
 public:

  Pyload_getCaptchaTaskStatus_args() : tid(0) {
  }

  virtual ~Pyload_getCaptchaTaskStatus_args() throw() {}

  TaskID tid;

  _Pyload_getCaptchaTaskStatus_args__isset __isset;

  void __set_tid(const TaskID val) {
    tid = val;
  }

  bool operator == (const Pyload_getCaptchaTaskStatus_args & rhs) const
  {
    if (!(tid == rhs.tid))
      return false;
    return true;
  }
  bool operator != (const Pyload_getCaptchaTaskStatus_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getCaptchaTaskStatus_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getCaptchaTaskStatus_pargs {
 public:


  virtual ~Pyload_getCaptchaTaskStatus_pargs() throw() {}

  const TaskID* tid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getCaptchaTaskStatus_result__isset {
  _Pyload_getCaptchaTaskStatus_result__isset() : success(false) {}
  bool success;
} _Pyload_getCaptchaTaskStatus_result__isset;

class Pyload_getCaptchaTaskStatus_result {
 public:

  Pyload_getCaptchaTaskStatus_result() : success("") {
  }

  virtual ~Pyload_getCaptchaTaskStatus_result() throw() {}

  std::string success;

  _Pyload_getCaptchaTaskStatus_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const Pyload_getCaptchaTaskStatus_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getCaptchaTaskStatus_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getCaptchaTaskStatus_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getCaptchaTaskStatus_presult__isset {
  _Pyload_getCaptchaTaskStatus_presult__isset() : success(false) {}
  bool success;
} _Pyload_getCaptchaTaskStatus_presult__isset;

class Pyload_getCaptchaTaskStatus_presult {
 public:


  virtual ~Pyload_getCaptchaTaskStatus_presult() throw() {}

  std::string* success;

  _Pyload_getCaptchaTaskStatus_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_setCaptchaResult_args__isset {
  _Pyload_setCaptchaResult_args__isset() : tid(false), result(false) {}
  bool tid;
  bool result;
} _Pyload_setCaptchaResult_args__isset;

class Pyload_setCaptchaResult_args {
 public:

  Pyload_setCaptchaResult_args() : tid(0), result("") {
  }

  virtual ~Pyload_setCaptchaResult_args() throw() {}

  TaskID tid;
  std::string result;

  _Pyload_setCaptchaResult_args__isset __isset;

  void __set_tid(const TaskID val) {
    tid = val;
  }

  void __set_result(const std::string& val) {
    result = val;
  }

  bool operator == (const Pyload_setCaptchaResult_args & rhs) const
  {
    if (!(tid == rhs.tid))
      return false;
    if (!(result == rhs.result))
      return false;
    return true;
  }
  bool operator != (const Pyload_setCaptchaResult_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_setCaptchaResult_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_setCaptchaResult_pargs {
 public:


  virtual ~Pyload_setCaptchaResult_pargs() throw() {}

  const TaskID* tid;
  const std::string* result;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_setCaptchaResult_result {
 public:

  Pyload_setCaptchaResult_result() {
  }

  virtual ~Pyload_setCaptchaResult_result() throw() {}


  bool operator == (const Pyload_setCaptchaResult_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_setCaptchaResult_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_setCaptchaResult_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_setCaptchaResult_presult {
 public:


  virtual ~Pyload_setCaptchaResult_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_getEvents_args__isset {
  _Pyload_getEvents_args__isset() : uuid(false) {}
  bool uuid;
} _Pyload_getEvents_args__isset;

class Pyload_getEvents_args {
 public:

  Pyload_getEvents_args() : uuid("") {
  }

  virtual ~Pyload_getEvents_args() throw() {}

  std::string uuid;

  _Pyload_getEvents_args__isset __isset;

  void __set_uuid(const std::string& val) {
    uuid = val;
  }

  bool operator == (const Pyload_getEvents_args & rhs) const
  {
    if (!(uuid == rhs.uuid))
      return false;
    return true;
  }
  bool operator != (const Pyload_getEvents_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getEvents_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getEvents_pargs {
 public:


  virtual ~Pyload_getEvents_pargs() throw() {}

  const std::string* uuid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getEvents_result__isset {
  _Pyload_getEvents_result__isset() : success(false) {}
  bool success;
} _Pyload_getEvents_result__isset;

class Pyload_getEvents_result {
 public:

  Pyload_getEvents_result() {
  }

  virtual ~Pyload_getEvents_result() throw() {}

  std::vector<Event>  success;

  _Pyload_getEvents_result__isset __isset;

  void __set_success(const std::vector<Event> & val) {
    success = val;
  }

  bool operator == (const Pyload_getEvents_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getEvents_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getEvents_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getEvents_presult__isset {
  _Pyload_getEvents_presult__isset() : success(false) {}
  bool success;
} _Pyload_getEvents_presult__isset;

class Pyload_getEvents_presult {
 public:


  virtual ~Pyload_getEvents_presult() throw() {}

  std::vector<Event> * success;

  _Pyload_getEvents_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_getAccounts_args__isset {
  _Pyload_getAccounts_args__isset() : refresh(false) {}
  bool refresh;
} _Pyload_getAccounts_args__isset;

class Pyload_getAccounts_args {
 public:

  Pyload_getAccounts_args() : refresh(0) {
  }

  virtual ~Pyload_getAccounts_args() throw() {}

  bool refresh;

  _Pyload_getAccounts_args__isset __isset;

  void __set_refresh(const bool val) {
    refresh = val;
  }

  bool operator == (const Pyload_getAccounts_args & rhs) const
  {
    if (!(refresh == rhs.refresh))
      return false;
    return true;
  }
  bool operator != (const Pyload_getAccounts_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getAccounts_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getAccounts_pargs {
 public:


  virtual ~Pyload_getAccounts_pargs() throw() {}

  const bool* refresh;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getAccounts_result__isset {
  _Pyload_getAccounts_result__isset() : success(false) {}
  bool success;
} _Pyload_getAccounts_result__isset;

class Pyload_getAccounts_result {
 public:

  Pyload_getAccounts_result() {
  }

  virtual ~Pyload_getAccounts_result() throw() {}

  std::vector<AccountInfo>  success;

  _Pyload_getAccounts_result__isset __isset;

  void __set_success(const std::vector<AccountInfo> & val) {
    success = val;
  }

  bool operator == (const Pyload_getAccounts_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getAccounts_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getAccounts_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getAccounts_presult__isset {
  _Pyload_getAccounts_presult__isset() : success(false) {}
  bool success;
} _Pyload_getAccounts_presult__isset;

class Pyload_getAccounts_presult {
 public:


  virtual ~Pyload_getAccounts_presult() throw() {}

  std::vector<AccountInfo> * success;

  _Pyload_getAccounts_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_getAccountTypes_args {
 public:

  Pyload_getAccountTypes_args() {
  }

  virtual ~Pyload_getAccountTypes_args() throw() {}


  bool operator == (const Pyload_getAccountTypes_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_getAccountTypes_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getAccountTypes_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getAccountTypes_pargs {
 public:


  virtual ~Pyload_getAccountTypes_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getAccountTypes_result__isset {
  _Pyload_getAccountTypes_result__isset() : success(false) {}
  bool success;
} _Pyload_getAccountTypes_result__isset;

class Pyload_getAccountTypes_result {
 public:

  Pyload_getAccountTypes_result() {
  }

  virtual ~Pyload_getAccountTypes_result() throw() {}

  std::vector<std::string>  success;

  _Pyload_getAccountTypes_result__isset __isset;

  void __set_success(const std::vector<std::string> & val) {
    success = val;
  }

  bool operator == (const Pyload_getAccountTypes_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getAccountTypes_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getAccountTypes_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getAccountTypes_presult__isset {
  _Pyload_getAccountTypes_presult__isset() : success(false) {}
  bool success;
} _Pyload_getAccountTypes_presult__isset;

class Pyload_getAccountTypes_presult {
 public:


  virtual ~Pyload_getAccountTypes_presult() throw() {}

  std::vector<std::string> * success;

  _Pyload_getAccountTypes_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_updateAccount_args__isset {
  _Pyload_updateAccount_args__isset() : plugin(false), account(false), password(false), options(false) {}
  bool plugin;
  bool account;
  bool password;
  bool options;
} _Pyload_updateAccount_args__isset;

class Pyload_updateAccount_args {
 public:

  Pyload_updateAccount_args() : plugin(""), account(""), password("") {
  }

  virtual ~Pyload_updateAccount_args() throw() {}

  PluginName plugin;
  std::string account;
  std::string password;
  std::map<std::string, std::string>  options;

  _Pyload_updateAccount_args__isset __isset;

  void __set_plugin(const PluginName& val) {
    plugin = val;
  }

  void __set_account(const std::string& val) {
    account = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  void __set_options(const std::map<std::string, std::string> & val) {
    options = val;
  }

  bool operator == (const Pyload_updateAccount_args & rhs) const
  {
    if (!(plugin == rhs.plugin))
      return false;
    if (!(account == rhs.account))
      return false;
    if (!(password == rhs.password))
      return false;
    if (!(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const Pyload_updateAccount_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_updateAccount_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_updateAccount_pargs {
 public:


  virtual ~Pyload_updateAccount_pargs() throw() {}

  const PluginName* plugin;
  const std::string* account;
  const std::string* password;
  const std::map<std::string, std::string> * options;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_updateAccount_result {
 public:

  Pyload_updateAccount_result() {
  }

  virtual ~Pyload_updateAccount_result() throw() {}


  bool operator == (const Pyload_updateAccount_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_updateAccount_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_updateAccount_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_updateAccount_presult {
 public:


  virtual ~Pyload_updateAccount_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_removeAccount_args__isset {
  _Pyload_removeAccount_args__isset() : plugin(false), account(false) {}
  bool plugin;
  bool account;
} _Pyload_removeAccount_args__isset;

class Pyload_removeAccount_args {
 public:

  Pyload_removeAccount_args() : plugin(""), account("") {
  }

  virtual ~Pyload_removeAccount_args() throw() {}

  PluginName plugin;
  std::string account;

  _Pyload_removeAccount_args__isset __isset;

  void __set_plugin(const PluginName& val) {
    plugin = val;
  }

  void __set_account(const std::string& val) {
    account = val;
  }

  bool operator == (const Pyload_removeAccount_args & rhs) const
  {
    if (!(plugin == rhs.plugin))
      return false;
    if (!(account == rhs.account))
      return false;
    return true;
  }
  bool operator != (const Pyload_removeAccount_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_removeAccount_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_removeAccount_pargs {
 public:


  virtual ~Pyload_removeAccount_pargs() throw() {}

  const PluginName* plugin;
  const std::string* account;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_removeAccount_result {
 public:

  Pyload_removeAccount_result() {
  }

  virtual ~Pyload_removeAccount_result() throw() {}


  bool operator == (const Pyload_removeAccount_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_removeAccount_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_removeAccount_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_removeAccount_presult {
 public:


  virtual ~Pyload_removeAccount_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_login_args__isset {
  _Pyload_login_args__isset() : username(false), password(false) {}
  bool username;
  bool password;
} _Pyload_login_args__isset;

class Pyload_login_args {
 public:

  Pyload_login_args() : username(""), password("") {
  }

  virtual ~Pyload_login_args() throw() {}

  std::string username;
  std::string password;

  _Pyload_login_args__isset __isset;

  void __set_username(const std::string& val) {
    username = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  bool operator == (const Pyload_login_args & rhs) const
  {
    if (!(username == rhs.username))
      return false;
    if (!(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const Pyload_login_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_login_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_login_pargs {
 public:


  virtual ~Pyload_login_pargs() throw() {}

  const std::string* username;
  const std::string* password;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_login_result__isset {
  _Pyload_login_result__isset() : success(false) {}
  bool success;
} _Pyload_login_result__isset;

class Pyload_login_result {
 public:

  Pyload_login_result() : success(0) {
  }

  virtual ~Pyload_login_result() throw() {}

  bool success;

  _Pyload_login_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  bool operator == (const Pyload_login_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_login_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_login_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_login_presult__isset {
  _Pyload_login_presult__isset() : success(false) {}
  bool success;
} _Pyload_login_presult__isset;

class Pyload_login_presult {
 public:


  virtual ~Pyload_login_presult() throw() {}

  bool* success;

  _Pyload_login_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_getUserData_args__isset {
  _Pyload_getUserData_args__isset() : username(false), password(false) {}
  bool username;
  bool password;
} _Pyload_getUserData_args__isset;

class Pyload_getUserData_args {
 public:

  Pyload_getUserData_args() : username(""), password("") {
  }

  virtual ~Pyload_getUserData_args() throw() {}

  std::string username;
  std::string password;

  _Pyload_getUserData_args__isset __isset;

  void __set_username(const std::string& val) {
    username = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  bool operator == (const Pyload_getUserData_args & rhs) const
  {
    if (!(username == rhs.username))
      return false;
    if (!(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const Pyload_getUserData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getUserData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getUserData_pargs {
 public:


  virtual ~Pyload_getUserData_pargs() throw() {}

  const std::string* username;
  const std::string* password;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getUserData_result__isset {
  _Pyload_getUserData_result__isset() : success(false) {}
  bool success;
} _Pyload_getUserData_result__isset;

class Pyload_getUserData_result {
 public:

  Pyload_getUserData_result() {
  }

  virtual ~Pyload_getUserData_result() throw() {}

  UserData success;

  _Pyload_getUserData_result__isset __isset;

  void __set_success(const UserData& val) {
    success = val;
  }

  bool operator == (const Pyload_getUserData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getUserData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getUserData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getUserData_presult__isset {
  _Pyload_getUserData_presult__isset() : success(false) {}
  bool success;
} _Pyload_getUserData_presult__isset;

class Pyload_getUserData_presult {
 public:


  virtual ~Pyload_getUserData_presult() throw() {}

  UserData* success;

  _Pyload_getUserData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_getServices_args {
 public:

  Pyload_getServices_args() {
  }

  virtual ~Pyload_getServices_args() throw() {}


  bool operator == (const Pyload_getServices_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_getServices_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getServices_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getServices_pargs {
 public:


  virtual ~Pyload_getServices_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getServices_result__isset {
  _Pyload_getServices_result__isset() : success(false) {}
  bool success;
} _Pyload_getServices_result__isset;

class Pyload_getServices_result {
 public:

  Pyload_getServices_result() {
  }

  virtual ~Pyload_getServices_result() throw() {}

  std::map<PluginName, std::map<std::string, std::string> >  success;

  _Pyload_getServices_result__isset __isset;

  void __set_success(const std::map<PluginName, std::map<std::string, std::string> > & val) {
    success = val;
  }

  bool operator == (const Pyload_getServices_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getServices_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getServices_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getServices_presult__isset {
  _Pyload_getServices_presult__isset() : success(false) {}
  bool success;
} _Pyload_getServices_presult__isset;

class Pyload_getServices_presult {
 public:


  virtual ~Pyload_getServices_presult() throw() {}

  std::map<PluginName, std::map<std::string, std::string> > * success;

  _Pyload_getServices_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_hasService_args__isset {
  _Pyload_hasService_args__isset() : plugin(false), func(false) {}
  bool plugin;
  bool func;
} _Pyload_hasService_args__isset;

class Pyload_hasService_args {
 public:

  Pyload_hasService_args() : plugin(""), func("") {
  }

  virtual ~Pyload_hasService_args() throw() {}

  PluginName plugin;
  std::string func;

  _Pyload_hasService_args__isset __isset;

  void __set_plugin(const PluginName& val) {
    plugin = val;
  }

  void __set_func(const std::string& val) {
    func = val;
  }

  bool operator == (const Pyload_hasService_args & rhs) const
  {
    if (!(plugin == rhs.plugin))
      return false;
    if (!(func == rhs.func))
      return false;
    return true;
  }
  bool operator != (const Pyload_hasService_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_hasService_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_hasService_pargs {
 public:


  virtual ~Pyload_hasService_pargs() throw() {}

  const PluginName* plugin;
  const std::string* func;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_hasService_result__isset {
  _Pyload_hasService_result__isset() : success(false) {}
  bool success;
} _Pyload_hasService_result__isset;

class Pyload_hasService_result {
 public:

  Pyload_hasService_result() : success(0) {
  }

  virtual ~Pyload_hasService_result() throw() {}

  bool success;

  _Pyload_hasService_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  bool operator == (const Pyload_hasService_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_hasService_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_hasService_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_hasService_presult__isset {
  _Pyload_hasService_presult__isset() : success(false) {}
  bool success;
} _Pyload_hasService_presult__isset;

class Pyload_hasService_presult {
 public:


  virtual ~Pyload_hasService_presult() throw() {}

  bool* success;

  _Pyload_hasService_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_call_args__isset {
  _Pyload_call_args__isset() : info(false) {}
  bool info;
} _Pyload_call_args__isset;

class Pyload_call_args {
 public:

  Pyload_call_args() {
  }

  virtual ~Pyload_call_args() throw() {}

  ServiceCall info;

  _Pyload_call_args__isset __isset;

  void __set_info(const ServiceCall& val) {
    info = val;
  }

  bool operator == (const Pyload_call_args & rhs) const
  {
    if (!(info == rhs.info))
      return false;
    return true;
  }
  bool operator != (const Pyload_call_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_call_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_call_pargs {
 public:


  virtual ~Pyload_call_pargs() throw() {}

  const ServiceCall* info;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_call_result__isset {
  _Pyload_call_result__isset() : success(false), ex(false), e(false) {}
  bool success;
  bool ex;
  bool e;
} _Pyload_call_result__isset;

class Pyload_call_result {
 public:

  Pyload_call_result() : success("") {
  }

  virtual ~Pyload_call_result() throw() {}

  std::string success;
  ServiceDoesNotExists ex;
  ServiceException e;

  _Pyload_call_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ex(const ServiceDoesNotExists& val) {
    ex = val;
  }

  void __set_e(const ServiceException& val) {
    e = val;
  }

  bool operator == (const Pyload_call_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pyload_call_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_call_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_call_presult__isset {
  _Pyload_call_presult__isset() : success(false), ex(false), e(false) {}
  bool success;
  bool ex;
  bool e;
} _Pyload_call_presult__isset;

class Pyload_call_presult {
 public:


  virtual ~Pyload_call_presult() throw() {}

  std::string* success;
  ServiceDoesNotExists ex;
  ServiceException e;

  _Pyload_call_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Pyload_getAllInfo_args {
 public:

  Pyload_getAllInfo_args() {
  }

  virtual ~Pyload_getAllInfo_args() throw() {}


  bool operator == (const Pyload_getAllInfo_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pyload_getAllInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getAllInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getAllInfo_pargs {
 public:


  virtual ~Pyload_getAllInfo_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getAllInfo_result__isset {
  _Pyload_getAllInfo_result__isset() : success(false) {}
  bool success;
} _Pyload_getAllInfo_result__isset;

class Pyload_getAllInfo_result {
 public:

  Pyload_getAllInfo_result() {
  }

  virtual ~Pyload_getAllInfo_result() throw() {}

  std::map<PluginName, std::map<std::string, std::string> >  success;

  _Pyload_getAllInfo_result__isset __isset;

  void __set_success(const std::map<PluginName, std::map<std::string, std::string> > & val) {
    success = val;
  }

  bool operator == (const Pyload_getAllInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getAllInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getAllInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getAllInfo_presult__isset {
  _Pyload_getAllInfo_presult__isset() : success(false) {}
  bool success;
} _Pyload_getAllInfo_presult__isset;

class Pyload_getAllInfo_presult {
 public:


  virtual ~Pyload_getAllInfo_presult() throw() {}

  std::map<PluginName, std::map<std::string, std::string> > * success;

  _Pyload_getAllInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pyload_getInfoByPlugin_args__isset {
  _Pyload_getInfoByPlugin_args__isset() : plugin(false) {}
  bool plugin;
} _Pyload_getInfoByPlugin_args__isset;

class Pyload_getInfoByPlugin_args {
 public:

  Pyload_getInfoByPlugin_args() : plugin("") {
  }

  virtual ~Pyload_getInfoByPlugin_args() throw() {}

  PluginName plugin;

  _Pyload_getInfoByPlugin_args__isset __isset;

  void __set_plugin(const PluginName& val) {
    plugin = val;
  }

  bool operator == (const Pyload_getInfoByPlugin_args & rhs) const
  {
    if (!(plugin == rhs.plugin))
      return false;
    return true;
  }
  bool operator != (const Pyload_getInfoByPlugin_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getInfoByPlugin_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pyload_getInfoByPlugin_pargs {
 public:


  virtual ~Pyload_getInfoByPlugin_pargs() throw() {}

  const PluginName* plugin;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getInfoByPlugin_result__isset {
  _Pyload_getInfoByPlugin_result__isset() : success(false) {}
  bool success;
} _Pyload_getInfoByPlugin_result__isset;

class Pyload_getInfoByPlugin_result {
 public:

  Pyload_getInfoByPlugin_result() {
  }

  virtual ~Pyload_getInfoByPlugin_result() throw() {}

  std::map<std::string, std::string>  success;

  _Pyload_getInfoByPlugin_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val) {
    success = val;
  }

  bool operator == (const Pyload_getInfoByPlugin_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pyload_getInfoByPlugin_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pyload_getInfoByPlugin_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pyload_getInfoByPlugin_presult__isset {
  _Pyload_getInfoByPlugin_presult__isset() : success(false) {}
  bool success;
} _Pyload_getInfoByPlugin_presult__isset;

class Pyload_getInfoByPlugin_presult {
 public:


  virtual ~Pyload_getInfoByPlugin_presult() throw() {}

  std::map<std::string, std::string> * success;

  _Pyload_getInfoByPlugin_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class PyloadClient : virtual public PyloadIf {
 public:
  PyloadClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  PyloadClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void getConfigValue(std::string& _return, const std::string& category, const std::string& option, const std::string& section);
  void send_getConfigValue(const std::string& category, const std::string& option, const std::string& section);
  void recv_getConfigValue(std::string& _return);
  void setConfigValue(const std::string& category, const std::string& option, const std::string& value, const std::string& section);
  void send_setConfigValue(const std::string& category, const std::string& option, const std::string& value, const std::string& section);
  void recv_setConfigValue();
  void getConfig(std::map<std::string, ConfigSection> & _return);
  void send_getConfig();
  void recv_getConfig(std::map<std::string, ConfigSection> & _return);
  void getPluginConfig(std::map<std::string, ConfigSection> & _return);
  void send_getPluginConfig();
  void recv_getPluginConfig(std::map<std::string, ConfigSection> & _return);
  void pauseServer();
  void send_pauseServer();
  void recv_pauseServer();
  void unpauseServer();
  void send_unpauseServer();
  void recv_unpauseServer();
  bool togglePause();
  void send_togglePause();
  bool recv_togglePause();
  void statusServer(ServerStatus& _return);
  void send_statusServer();
  void recv_statusServer(ServerStatus& _return);
  int64_t freeSpace();
  void send_freeSpace();
  int64_t recv_freeSpace();
  void getServerVersion(std::string& _return);
  void send_getServerVersion();
  void recv_getServerVersion(std::string& _return);
  void kill();
  void send_kill();
  void recv_kill();
  void restart();
  void send_restart();
  void recv_restart();
  void getLog(std::vector<std::string> & _return, const int32_t offset);
  void send_getLog(const int32_t offset);
  void recv_getLog(std::vector<std::string> & _return);
  bool isTimeDownload();
  void send_isTimeDownload();
  bool recv_isTimeDownload();
  bool isTimeReconnect();
  void send_isTimeReconnect();
  bool recv_isTimeReconnect();
  bool toggleReconnect();
  void send_toggleReconnect();
  bool recv_toggleReconnect();
  void generatePackages(std::map<std::string, LinkList> & _return, const LinkList& links);
  void send_generatePackages(const LinkList& links);
  void recv_generatePackages(std::map<std::string, LinkList> & _return);
  void checkURLs(std::map<PluginName, LinkList> & _return, const LinkList& urls);
  void send_checkURLs(const LinkList& urls);
  void recv_checkURLs(std::map<PluginName, LinkList> & _return);
  void parseURLs(std::map<PluginName, LinkList> & _return, const std::string& html);
  void send_parseURLs(const std::string& html);
  void recv_parseURLs(std::map<PluginName, LinkList> & _return);
  void checkOnlineStatus(OnlineCheck& _return, const LinkList& urls);
  void send_checkOnlineStatus(const LinkList& urls);
  void recv_checkOnlineStatus(OnlineCheck& _return);
  void checkOnlineStatusContainer(OnlineCheck& _return, const LinkList& urls, const std::string& filename, const std::string& data);
  void send_checkOnlineStatusContainer(const LinkList& urls, const std::string& filename, const std::string& data);
  void recv_checkOnlineStatusContainer(OnlineCheck& _return);
  void pollResults(OnlineCheck& _return, const ResultID rid);
  void send_pollResults(const ResultID rid);
  void recv_pollResults(OnlineCheck& _return);
  void statusDownloads(std::vector<DownloadInfo> & _return);
  void send_statusDownloads();
  void recv_statusDownloads(std::vector<DownloadInfo> & _return);
  void getPackageData(PackageData& _return, const PackageID pid);
  void send_getPackageData(const PackageID pid);
  void recv_getPackageData(PackageData& _return);
  void getPackageInfo(PackageData& _return, const PackageID pid);
  void send_getPackageInfo(const PackageID pid);
  void recv_getPackageInfo(PackageData& _return);
  void getFileData(FileData& _return, const FileID fid);
  void send_getFileData(const FileID fid);
  void recv_getFileData(FileData& _return);
  void getQueue(std::vector<PackageData> & _return);
  void send_getQueue();
  void recv_getQueue(std::vector<PackageData> & _return);
  void getCollector(std::vector<PackageData> & _return);
  void send_getCollector();
  void recv_getCollector(std::vector<PackageData> & _return);
  void getQueueData(std::vector<PackageData> & _return);
  void send_getQueueData();
  void recv_getQueueData(std::vector<PackageData> & _return);
  void getCollectorData(std::vector<PackageData> & _return);
  void send_getCollectorData();
  void recv_getCollectorData(std::vector<PackageData> & _return);
  void getPackageOrder(std::map<int16_t, PackageID> & _return, const Destination::type destination);
  void send_getPackageOrder(const Destination::type destination);
  void recv_getPackageOrder(std::map<int16_t, PackageID> & _return);
  void getFileOrder(std::map<int16_t, FileID> & _return, const PackageID pid);
  void send_getFileOrder(const PackageID pid);
  void recv_getFileOrder(std::map<int16_t, FileID> & _return);
  void generateAndAddPackages(std::vector<PackageID> & _return, const LinkList& links, const Destination::type dest);
  void send_generateAndAddPackages(const LinkList& links, const Destination::type dest);
  void recv_generateAndAddPackages(std::vector<PackageID> & _return);
  PackageID addPackage(const std::string& name, const LinkList& links, const Destination::type dest);
  void send_addPackage(const std::string& name, const LinkList& links, const Destination::type dest);
  PackageID recv_addPackage();
  void addFiles(const PackageID pid, const LinkList& links);
  void send_addFiles(const PackageID pid, const LinkList& links);
  void recv_addFiles();
  void uploadContainer(const std::string& filename, const std::string& data);
  void send_uploadContainer(const std::string& filename, const std::string& data);
  void recv_uploadContainer();
  void deleteFiles(const std::vector<FileID> & fids);
  void send_deleteFiles(const std::vector<FileID> & fids);
  void recv_deleteFiles();
  void deletePackages(const std::vector<PackageID> & pids);
  void send_deletePackages(const std::vector<PackageID> & pids);
  void recv_deletePackages();
  void pushToQueue(const PackageID pid);
  void send_pushToQueue(const PackageID pid);
  void recv_pushToQueue();
  void pullFromQueue(const PackageID pid);
  void send_pullFromQueue(const PackageID pid);
  void recv_pullFromQueue();
  void restartPackage(const PackageID pid);
  void send_restartPackage(const PackageID pid);
  void recv_restartPackage();
  void restartFile(const FileID fid);
  void send_restartFile(const FileID fid);
  void recv_restartFile();
  void recheckPackage(const PackageID pid);
  void send_recheckPackage(const PackageID pid);
  void recv_recheckPackage();
  void stopAllDownloads();
  void send_stopAllDownloads();
  void recv_stopAllDownloads();
  void stopDownloads(const std::vector<FileID> & fids);
  void send_stopDownloads(const std::vector<FileID> & fids);
  void recv_stopDownloads();
  void setPackageName(const PackageID pid, const std::string& name);
  void send_setPackageName(const PackageID pid, const std::string& name);
  void recv_setPackageName();
  void movePackage(const Destination::type destination, const PackageID pid);
  void send_movePackage(const Destination::type destination, const PackageID pid);
  void recv_movePackage();
  void moveFiles(const std::vector<FileID> & fids, const PackageID pid);
  void send_moveFiles(const std::vector<FileID> & fids, const PackageID pid);
  void recv_moveFiles();
  void orderPackage(const PackageID pid, const int16_t position);
  void send_orderPackage(const PackageID pid, const int16_t position);
  void recv_orderPackage();
  void orderFile(const FileID fid, const int16_t position);
  void send_orderFile(const FileID fid, const int16_t position);
  void recv_orderFile();
  void setPackageData(const PackageID pid, const std::map<std::string, std::string> & data);
  void send_setPackageData(const PackageID pid, const std::map<std::string, std::string> & data);
  void recv_setPackageData();
  void deleteFinished();
  void send_deleteFinished();
  void recv_deleteFinished();
  void restartFailed();
  void send_restartFailed();
  void recv_restartFailed();
  bool isCaptchaWaiting();
  void send_isCaptchaWaiting();
  bool recv_isCaptchaWaiting();
  void getCaptchaTask(CaptchaTask& _return, const bool exclusive);
  void send_getCaptchaTask(const bool exclusive);
  void recv_getCaptchaTask(CaptchaTask& _return);
  void getCaptchaTaskStatus(std::string& _return, const TaskID tid);
  void send_getCaptchaTaskStatus(const TaskID tid);
  void recv_getCaptchaTaskStatus(std::string& _return);
  void setCaptchaResult(const TaskID tid, const std::string& result);
  void send_setCaptchaResult(const TaskID tid, const std::string& result);
  void recv_setCaptchaResult();
  void getEvents(std::vector<Event> & _return, const std::string& uuid);
  void send_getEvents(const std::string& uuid);
  void recv_getEvents(std::vector<Event> & _return);
  void getAccounts(std::vector<AccountInfo> & _return, const bool refresh);
  void send_getAccounts(const bool refresh);
  void recv_getAccounts(std::vector<AccountInfo> & _return);
  void getAccountTypes(std::vector<std::string> & _return);
  void send_getAccountTypes();
  void recv_getAccountTypes(std::vector<std::string> & _return);
  void updateAccount(const PluginName& plugin, const std::string& account, const std::string& password, const std::map<std::string, std::string> & options);
  void send_updateAccount(const PluginName& plugin, const std::string& account, const std::string& password, const std::map<std::string, std::string> & options);
  void recv_updateAccount();
  void removeAccount(const PluginName& plugin, const std::string& account);
  void send_removeAccount(const PluginName& plugin, const std::string& account);
  void recv_removeAccount();
  bool login(const std::string& username, const std::string& password);
  void send_login(const std::string& username, const std::string& password);
  bool recv_login();
  void getUserData(UserData& _return, const std::string& username, const std::string& password);
  void send_getUserData(const std::string& username, const std::string& password);
  void recv_getUserData(UserData& _return);
  void getServices(std::map<PluginName, std::map<std::string, std::string> > & _return);
  void send_getServices();
  void recv_getServices(std::map<PluginName, std::map<std::string, std::string> > & _return);
  bool hasService(const PluginName& plugin, const std::string& func);
  void send_hasService(const PluginName& plugin, const std::string& func);
  bool recv_hasService();
  void call(std::string& _return, const ServiceCall& info);
  void send_call(const ServiceCall& info);
  void recv_call(std::string& _return);
  void getAllInfo(std::map<PluginName, std::map<std::string, std::string> > & _return);
  void send_getAllInfo();
  void recv_getAllInfo(std::map<PluginName, std::map<std::string, std::string> > & _return);
  void getInfoByPlugin(std::map<std::string, std::string> & _return, const PluginName& plugin);
  void send_getInfoByPlugin(const PluginName& plugin);
  void recv_getInfoByPlugin(std::map<std::string, std::string> & _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class PyloadProcessor : public ::apache::thrift::TProcessor {
 protected:
  boost::shared_ptr<PyloadIf> iface_;
  virtual bool process_fn(apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid, void* callContext);
 private:
  std::map<std::string, void (PyloadProcessor::*)(int32_t, apache::thrift::protocol::TProtocol*, apache::thrift::protocol::TProtocol*, void*)> processMap_;
  void process_getConfigValue(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setConfigValue(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getConfig(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getPluginConfig(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pauseServer(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unpauseServer(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_togglePause(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_statusServer(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_freeSpace(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getServerVersion(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_kill(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_restart(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getLog(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_isTimeDownload(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_isTimeReconnect(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_toggleReconnect(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_generatePackages(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_checkURLs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_parseURLs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_checkOnlineStatus(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_checkOnlineStatusContainer(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pollResults(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_statusDownloads(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getPackageData(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getPackageInfo(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getFileData(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getQueue(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getCollector(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getQueueData(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getCollectorData(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getPackageOrder(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getFileOrder(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_generateAndAddPackages(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_addPackage(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_addFiles(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_uploadContainer(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteFiles(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deletePackages(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pushToQueue(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pullFromQueue(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_restartPackage(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_restartFile(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_recheckPackage(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_stopAllDownloads(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_stopDownloads(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setPackageName(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_movePackage(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_moveFiles(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_orderPackage(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_orderFile(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setPackageData(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteFinished(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_restartFailed(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_isCaptchaWaiting(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getCaptchaTask(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getCaptchaTaskStatus(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setCaptchaResult(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getEvents(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getAccounts(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getAccountTypes(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateAccount(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeAccount(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_login(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getUserData(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getServices(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hasService(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_call(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getAllInfo(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getInfoByPlugin(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  PyloadProcessor(boost::shared_ptr<PyloadIf> iface) :
    iface_(iface) {
    processMap_["getConfigValue"] = &PyloadProcessor::process_getConfigValue;
    processMap_["setConfigValue"] = &PyloadProcessor::process_setConfigValue;
    processMap_["getConfig"] = &PyloadProcessor::process_getConfig;
    processMap_["getPluginConfig"] = &PyloadProcessor::process_getPluginConfig;
    processMap_["pauseServer"] = &PyloadProcessor::process_pauseServer;
    processMap_["unpauseServer"] = &PyloadProcessor::process_unpauseServer;
    processMap_["togglePause"] = &PyloadProcessor::process_togglePause;
    processMap_["statusServer"] = &PyloadProcessor::process_statusServer;
    processMap_["freeSpace"] = &PyloadProcessor::process_freeSpace;
    processMap_["getServerVersion"] = &PyloadProcessor::process_getServerVersion;
    processMap_["kill"] = &PyloadProcessor::process_kill;
    processMap_["restart"] = &PyloadProcessor::process_restart;
    processMap_["getLog"] = &PyloadProcessor::process_getLog;
    processMap_["isTimeDownload"] = &PyloadProcessor::process_isTimeDownload;
    processMap_["isTimeReconnect"] = &PyloadProcessor::process_isTimeReconnect;
    processMap_["toggleReconnect"] = &PyloadProcessor::process_toggleReconnect;
    processMap_["generatePackages"] = &PyloadProcessor::process_generatePackages;
    processMap_["checkURLs"] = &PyloadProcessor::process_checkURLs;
    processMap_["parseURLs"] = &PyloadProcessor::process_parseURLs;
    processMap_["checkOnlineStatus"] = &PyloadProcessor::process_checkOnlineStatus;
    processMap_["checkOnlineStatusContainer"] = &PyloadProcessor::process_checkOnlineStatusContainer;
    processMap_["pollResults"] = &PyloadProcessor::process_pollResults;
    processMap_["statusDownloads"] = &PyloadProcessor::process_statusDownloads;
    processMap_["getPackageData"] = &PyloadProcessor::process_getPackageData;
    processMap_["getPackageInfo"] = &PyloadProcessor::process_getPackageInfo;
    processMap_["getFileData"] = &PyloadProcessor::process_getFileData;
    processMap_["getQueue"] = &PyloadProcessor::process_getQueue;
    processMap_["getCollector"] = &PyloadProcessor::process_getCollector;
    processMap_["getQueueData"] = &PyloadProcessor::process_getQueueData;
    processMap_["getCollectorData"] = &PyloadProcessor::process_getCollectorData;
    processMap_["getPackageOrder"] = &PyloadProcessor::process_getPackageOrder;
    processMap_["getFileOrder"] = &PyloadProcessor::process_getFileOrder;
    processMap_["generateAndAddPackages"] = &PyloadProcessor::process_generateAndAddPackages;
    processMap_["addPackage"] = &PyloadProcessor::process_addPackage;
    processMap_["addFiles"] = &PyloadProcessor::process_addFiles;
    processMap_["uploadContainer"] = &PyloadProcessor::process_uploadContainer;
    processMap_["deleteFiles"] = &PyloadProcessor::process_deleteFiles;
    processMap_["deletePackages"] = &PyloadProcessor::process_deletePackages;
    processMap_["pushToQueue"] = &PyloadProcessor::process_pushToQueue;
    processMap_["pullFromQueue"] = &PyloadProcessor::process_pullFromQueue;
    processMap_["restartPackage"] = &PyloadProcessor::process_restartPackage;
    processMap_["restartFile"] = &PyloadProcessor::process_restartFile;
    processMap_["recheckPackage"] = &PyloadProcessor::process_recheckPackage;
    processMap_["stopAllDownloads"] = &PyloadProcessor::process_stopAllDownloads;
    processMap_["stopDownloads"] = &PyloadProcessor::process_stopDownloads;
    processMap_["setPackageName"] = &PyloadProcessor::process_setPackageName;
    processMap_["movePackage"] = &PyloadProcessor::process_movePackage;
    processMap_["moveFiles"] = &PyloadProcessor::process_moveFiles;
    processMap_["orderPackage"] = &PyloadProcessor::process_orderPackage;
    processMap_["orderFile"] = &PyloadProcessor::process_orderFile;
    processMap_["setPackageData"] = &PyloadProcessor::process_setPackageData;
    processMap_["deleteFinished"] = &PyloadProcessor::process_deleteFinished;
    processMap_["restartFailed"] = &PyloadProcessor::process_restartFailed;
    processMap_["isCaptchaWaiting"] = &PyloadProcessor::process_isCaptchaWaiting;
    processMap_["getCaptchaTask"] = &PyloadProcessor::process_getCaptchaTask;
    processMap_["getCaptchaTaskStatus"] = &PyloadProcessor::process_getCaptchaTaskStatus;
    processMap_["setCaptchaResult"] = &PyloadProcessor::process_setCaptchaResult;
    processMap_["getEvents"] = &PyloadProcessor::process_getEvents;
    processMap_["getAccounts"] = &PyloadProcessor::process_getAccounts;
    processMap_["getAccountTypes"] = &PyloadProcessor::process_getAccountTypes;
    processMap_["updateAccount"] = &PyloadProcessor::process_updateAccount;
    processMap_["removeAccount"] = &PyloadProcessor::process_removeAccount;
    processMap_["login"] = &PyloadProcessor::process_login;
    processMap_["getUserData"] = &PyloadProcessor::process_getUserData;
    processMap_["getServices"] = &PyloadProcessor::process_getServices;
    processMap_["hasService"] = &PyloadProcessor::process_hasService;
    processMap_["call"] = &PyloadProcessor::process_call;
    processMap_["getAllInfo"] = &PyloadProcessor::process_getAllInfo;
    processMap_["getInfoByPlugin"] = &PyloadProcessor::process_getInfoByPlugin;
  }

  virtual bool process(boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, void* callContext);
  virtual ~PyloadProcessor() {}
};

class PyloadProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  PyloadProcessorFactory(const ::boost::shared_ptr< PyloadIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< PyloadIfFactory > handlerFactory_;
};

class PyloadMultiface : virtual public PyloadIf {
 public:
  PyloadMultiface(std::vector<boost::shared_ptr<PyloadIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~PyloadMultiface() {}
 protected:
  std::vector<boost::shared_ptr<PyloadIf> > ifaces_;
  PyloadMultiface() {}
  void add(boost::shared_ptr<PyloadIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void getConfigValue(std::string& _return, const std::string& category, const std::string& option, const std::string& section) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getConfigValue(_return, category, option, section);
        return;
      } else {
        ifaces_[i]->getConfigValue(_return, category, option, section);
      }
    }
  }

  void setConfigValue(const std::string& category, const std::string& option, const std::string& value, const std::string& section) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->setConfigValue(category, option, value, section);
    }
  }

  void getConfig(std::map<std::string, ConfigSection> & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getConfig(_return);
        return;
      } else {
        ifaces_[i]->getConfig(_return);
      }
    }
  }

  void getPluginConfig(std::map<std::string, ConfigSection> & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getPluginConfig(_return);
        return;
      } else {
        ifaces_[i]->getPluginConfig(_return);
      }
    }
  }

  void pauseServer() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->pauseServer();
    }
  }

  void unpauseServer() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->unpauseServer();
    }
  }

  bool togglePause() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->togglePause();
      } else {
        ifaces_[i]->togglePause();
      }
    }
  }

  void statusServer(ServerStatus& _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->statusServer(_return);
        return;
      } else {
        ifaces_[i]->statusServer(_return);
      }
    }
  }

  int64_t freeSpace() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->freeSpace();
      } else {
        ifaces_[i]->freeSpace();
      }
    }
  }

  void getServerVersion(std::string& _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getServerVersion(_return);
        return;
      } else {
        ifaces_[i]->getServerVersion(_return);
      }
    }
  }

  void kill() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->kill();
    }
  }

  void restart() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->restart();
    }
  }

  void getLog(std::vector<std::string> & _return, const int32_t offset) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getLog(_return, offset);
        return;
      } else {
        ifaces_[i]->getLog(_return, offset);
      }
    }
  }

  bool isTimeDownload() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->isTimeDownload();
      } else {
        ifaces_[i]->isTimeDownload();
      }
    }
  }

  bool isTimeReconnect() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->isTimeReconnect();
      } else {
        ifaces_[i]->isTimeReconnect();
      }
    }
  }

  bool toggleReconnect() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->toggleReconnect();
      } else {
        ifaces_[i]->toggleReconnect();
      }
    }
  }

  void generatePackages(std::map<std::string, LinkList> & _return, const LinkList& links) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->generatePackages(_return, links);
        return;
      } else {
        ifaces_[i]->generatePackages(_return, links);
      }
    }
  }

  void checkURLs(std::map<PluginName, LinkList> & _return, const LinkList& urls) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->checkURLs(_return, urls);
        return;
      } else {
        ifaces_[i]->checkURLs(_return, urls);
      }
    }
  }

  void parseURLs(std::map<PluginName, LinkList> & _return, const std::string& html) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->parseURLs(_return, html);
        return;
      } else {
        ifaces_[i]->parseURLs(_return, html);
      }
    }
  }

  void checkOnlineStatus(OnlineCheck& _return, const LinkList& urls) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->checkOnlineStatus(_return, urls);
        return;
      } else {
        ifaces_[i]->checkOnlineStatus(_return, urls);
      }
    }
  }

  void checkOnlineStatusContainer(OnlineCheck& _return, const LinkList& urls, const std::string& filename, const std::string& data) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->checkOnlineStatusContainer(_return, urls, filename, data);
        return;
      } else {
        ifaces_[i]->checkOnlineStatusContainer(_return, urls, filename, data);
      }
    }
  }

  void pollResults(OnlineCheck& _return, const ResultID rid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->pollResults(_return, rid);
        return;
      } else {
        ifaces_[i]->pollResults(_return, rid);
      }
    }
  }

  void statusDownloads(std::vector<DownloadInfo> & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->statusDownloads(_return);
        return;
      } else {
        ifaces_[i]->statusDownloads(_return);
      }
    }
  }

  void getPackageData(PackageData& _return, const PackageID pid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getPackageData(_return, pid);
        return;
      } else {
        ifaces_[i]->getPackageData(_return, pid);
      }
    }
  }

  void getPackageInfo(PackageData& _return, const PackageID pid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getPackageInfo(_return, pid);
        return;
      } else {
        ifaces_[i]->getPackageInfo(_return, pid);
      }
    }
  }

  void getFileData(FileData& _return, const FileID fid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getFileData(_return, fid);
        return;
      } else {
        ifaces_[i]->getFileData(_return, fid);
      }
    }
  }

  void getQueue(std::vector<PackageData> & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getQueue(_return);
        return;
      } else {
        ifaces_[i]->getQueue(_return);
      }
    }
  }

  void getCollector(std::vector<PackageData> & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getCollector(_return);
        return;
      } else {
        ifaces_[i]->getCollector(_return);
      }
    }
  }

  void getQueueData(std::vector<PackageData> & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getQueueData(_return);
        return;
      } else {
        ifaces_[i]->getQueueData(_return);
      }
    }
  }

  void getCollectorData(std::vector<PackageData> & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getCollectorData(_return);
        return;
      } else {
        ifaces_[i]->getCollectorData(_return);
      }
    }
  }

  void getPackageOrder(std::map<int16_t, PackageID> & _return, const Destination::type destination) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getPackageOrder(_return, destination);
        return;
      } else {
        ifaces_[i]->getPackageOrder(_return, destination);
      }
    }
  }

  void getFileOrder(std::map<int16_t, FileID> & _return, const PackageID pid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getFileOrder(_return, pid);
        return;
      } else {
        ifaces_[i]->getFileOrder(_return, pid);
      }
    }
  }

  void generateAndAddPackages(std::vector<PackageID> & _return, const LinkList& links, const Destination::type dest) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->generateAndAddPackages(_return, links, dest);
        return;
      } else {
        ifaces_[i]->generateAndAddPackages(_return, links, dest);
      }
    }
  }

  PackageID addPackage(const std::string& name, const LinkList& links, const Destination::type dest) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->addPackage(name, links, dest);
      } else {
        ifaces_[i]->addPackage(name, links, dest);
      }
    }
  }

  void addFiles(const PackageID pid, const LinkList& links) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->addFiles(pid, links);
    }
  }

  void uploadContainer(const std::string& filename, const std::string& data) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->uploadContainer(filename, data);
    }
  }

  void deleteFiles(const std::vector<FileID> & fids) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->deleteFiles(fids);
    }
  }

  void deletePackages(const std::vector<PackageID> & pids) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->deletePackages(pids);
    }
  }

  void pushToQueue(const PackageID pid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->pushToQueue(pid);
    }
  }

  void pullFromQueue(const PackageID pid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->pullFromQueue(pid);
    }
  }

  void restartPackage(const PackageID pid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->restartPackage(pid);
    }
  }

  void restartFile(const FileID fid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->restartFile(fid);
    }
  }

  void recheckPackage(const PackageID pid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->recheckPackage(pid);
    }
  }

  void stopAllDownloads() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->stopAllDownloads();
    }
  }

  void stopDownloads(const std::vector<FileID> & fids) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->stopDownloads(fids);
    }
  }

  void setPackageName(const PackageID pid, const std::string& name) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->setPackageName(pid, name);
    }
  }

  void movePackage(const Destination::type destination, const PackageID pid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->movePackage(destination, pid);
    }
  }

  void moveFiles(const std::vector<FileID> & fids, const PackageID pid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->moveFiles(fids, pid);
    }
  }

  void orderPackage(const PackageID pid, const int16_t position) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->orderPackage(pid, position);
    }
  }

  void orderFile(const FileID fid, const int16_t position) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->orderFile(fid, position);
    }
  }

  void setPackageData(const PackageID pid, const std::map<std::string, std::string> & data) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->setPackageData(pid, data);
    }
  }

  void deleteFinished() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->deleteFinished();
    }
  }

  void restartFailed() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->restartFailed();
    }
  }

  bool isCaptchaWaiting() {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->isCaptchaWaiting();
      } else {
        ifaces_[i]->isCaptchaWaiting();
      }
    }
  }

  void getCaptchaTask(CaptchaTask& _return, const bool exclusive) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getCaptchaTask(_return, exclusive);
        return;
      } else {
        ifaces_[i]->getCaptchaTask(_return, exclusive);
      }
    }
  }

  void getCaptchaTaskStatus(std::string& _return, const TaskID tid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getCaptchaTaskStatus(_return, tid);
        return;
      } else {
        ifaces_[i]->getCaptchaTaskStatus(_return, tid);
      }
    }
  }

  void setCaptchaResult(const TaskID tid, const std::string& result) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->setCaptchaResult(tid, result);
    }
  }

  void getEvents(std::vector<Event> & _return, const std::string& uuid) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getEvents(_return, uuid);
        return;
      } else {
        ifaces_[i]->getEvents(_return, uuid);
      }
    }
  }

  void getAccounts(std::vector<AccountInfo> & _return, const bool refresh) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getAccounts(_return, refresh);
        return;
      } else {
        ifaces_[i]->getAccounts(_return, refresh);
      }
    }
  }

  void getAccountTypes(std::vector<std::string> & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getAccountTypes(_return);
        return;
      } else {
        ifaces_[i]->getAccountTypes(_return);
      }
    }
  }

  void updateAccount(const PluginName& plugin, const std::string& account, const std::string& password, const std::map<std::string, std::string> & options) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->updateAccount(plugin, account, password, options);
    }
  }

  void removeAccount(const PluginName& plugin, const std::string& account) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->removeAccount(plugin, account);
    }
  }

  bool login(const std::string& username, const std::string& password) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->login(username, password);
      } else {
        ifaces_[i]->login(username, password);
      }
    }
  }

  void getUserData(UserData& _return, const std::string& username, const std::string& password) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getUserData(_return, username, password);
        return;
      } else {
        ifaces_[i]->getUserData(_return, username, password);
      }
    }
  }

  void getServices(std::map<PluginName, std::map<std::string, std::string> > & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getServices(_return);
        return;
      } else {
        ifaces_[i]->getServices(_return);
      }
    }
  }

  bool hasService(const PluginName& plugin, const std::string& func) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->hasService(plugin, func);
      } else {
        ifaces_[i]->hasService(plugin, func);
      }
    }
  }

  void call(std::string& _return, const ServiceCall& info) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->call(_return, info);
        return;
      } else {
        ifaces_[i]->call(_return, info);
      }
    }
  }

  void getAllInfo(std::map<PluginName, std::map<std::string, std::string> > & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getAllInfo(_return);
        return;
      } else {
        ifaces_[i]->getAllInfo(_return);
      }
    }
  }

  void getInfoByPlugin(std::map<std::string, std::string> & _return, const PluginName& plugin) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getInfoByPlugin(_return, plugin);
        return;
      } else {
        ifaces_[i]->getInfoByPlugin(_return, plugin);
      }
    }
  }

};



#endif
